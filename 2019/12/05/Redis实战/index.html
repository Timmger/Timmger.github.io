<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NoSQL,Redis,">





  <link rel="alternate" href="/atom.xml" title="Time Manager" type="application/atom+xml">






<meta name="description" content="1. Redis简介 1.1 什么是 Redis Redis是一种基于键值（key-value）的NoSQL数据库。    数据存放于内存，读写性能惊人  Redis中的值由string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等组成   1.2 Redis 可以做什么缓存、排行榜系统">
<meta name="keywords" content="NoSQL,Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis开发运维">
<meta property="og:url" content="https://timmger.github.io/2019/12/05/Redis实战/index.html">
<meta property="og:site_name" content="Time Manager">
<meta property="og:description" content="1. Redis简介 1.1 什么是 Redis Redis是一种基于键值（key-value）的NoSQL数据库。    数据存放于内存，读写性能惊人  Redis中的值由string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等组成   1.2 Redis 可以做什么缓存、排行榜系统">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2019/12/07/uatJZwhesX6KSqI.png">
<meta property="og:image" content="https://i.loli.net/2019/12/07/1sIRxycaA2UzuWQ.png">
<meta property="og:image" content="https://i.loli.net/2019/12/08/iMbXZv9Rf6BHESL.png">
<meta property="og:image" content="https://i.loli.net/2019/12/14/DXE3kLAqy4Y5QWm.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/eJdH1iMTARu6K9X.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/KQgXFiNewdxClpW.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/soaDhGtHcm6BPey.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/qwF3s6G4zSpYDtP.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/Aq7iCrb5coPpzkm.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/ntPO5hrFNSXTE2Q.png">
<meta property="og:image" content="https://i.loli.net/2019/12/18/EelgUSTZjc7FGpD.png">
<meta property="og:image" content="https://i.loli.net/2019/12/18/X1KepagWdZf7Ak2.png">
<meta property="og:image" content="https://i.loli.net/2019/12/18/rfAtdL5HWhBeYmQ.png">
<meta property="og:image" content="https://i.loli.net/2019/12/18/qdRNDXKe4Jg57Z8.png">
<meta property="og:image" content="https://i.loli.net/2019/12/18/OL4pTU2mrw8ICJq.png">
<meta property="og:image" content="https://i.loli.net/2019/12/19/IdNXEhbcZSl19Pu.png">
<meta property="og:image" content="https://i.loli.net/2019/12/19/3ZS6CUtHE5ALf7F.png">
<meta property="og:image" content="https://i.loli.net/2019/12/19/VK96IkJFPwgH1nm.png">
<meta property="og:image" content="https://i.loli.net/2019/12/19/hq65RyD27v4YsBL.png">
<meta property="og:image" content="https://i.loli.net/2019/12/19/ldoPD2vxnNVKGrg.png">
<meta property="og:image" content="https://i.loli.net/2019/12/20/hVxSlLbJZdyOC2u.png">
<meta property="og:image" content="https://i.loli.net/2019/12/20/E91xMbiN6GaDVFH.png">
<meta property="og:image" content="https://i.loli.net/2019/12/20/wXu8mxZkfeDsdql.png">
<meta property="og:updated_time" content="2019-12-27T04:09:59.494Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis开发运维">
<meta name="twitter:description" content="1. Redis简介 1.1 什么是 Redis Redis是一种基于键值（key-value）的NoSQL数据库。    数据存放于内存，读写性能惊人  Redis中的值由string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等组成   1.2 Redis 可以做什么缓存、排行榜系统">
<meta name="twitter:image" content="https://i.loli.net/2019/12/07/uatJZwhesX6KSqI.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://timmger.github.io/2019/12/05/Redis实战/">





  <title>Redis开发运维 | Time Manager</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?40bd810474dac7f259f8afb92a8d103f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Timmger" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Time Manager</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">時は動き出す</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-design">
          <a href="http://design.timmger.site/dist/design.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-vcard (alias)"></i> <br>
            
            设计
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timmger.github.io/2019/12/05/Redis实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Allen Timmger">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time Manager">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis开发运维</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-05T18:13:53+08:00">
                2019-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/05/Redis实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/05/Redis实战/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/12/05/Redis实战/" class="leancloud_visitors" data-flag-title="Redis开发运维">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  61
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1. Redis简介"></a>1. Redis简介</h2><hr>
<h3 id="1-1-什么是-Redis"><a href="#1-1-什么是-Redis" class="headerlink" title="1.1 什么是 Redis"></a>1.1 什么是 Redis</h3><ul>
<li><p>Redis是一种基于<strong>键值</strong>（key-value）的<strong>NoSQL数据库</strong>。  </p>
</li>
<li><p>数据存放于<strong>内存</strong>，读写性能惊人</p>
</li>
<li><p>Redis中的值由string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等组成</p>
</li>
</ul>
<h3 id="1-2-Redis-可以做什么"><a href="#1-2-Redis-可以做什么" class="headerlink" title="1.2 Redis 可以做什么"></a>1.2 Redis 可以做什么</h3><p>缓存、排行榜系统、计数器应用、社交网络、消息队列系统</p>
<h3 id="1-3-安装-Redis"><a href="#1-3-安装-Redis" class="headerlink" title="1.3 安装 Redis"></a>1.3 安装 Redis</h3><p>源码安装:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-5.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-5.0.7 redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure>

<p>redis服务指定端口启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> reids-server --port 6380</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server /opt/redis/redis.conf</span></span><br></pre></td></tr></table></figure>

<p>命令行客户端启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6380</span></span><br></pre></td></tr></table></figure>

<p>停止 Redis 服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli shutdown</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有参数(nosave | save)代表是否生成持久化文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli shutdown nosave</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接保存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> save</span></span><br></pre></td></tr></table></figure>

<p>还可以使用 kill 关闭 Redis, 但不要使用 kill-9 强制杀死进程</p>
<h2 id="2-Redis-常用命令和数据结构"><a href="#2-Redis-常用命令和数据结构" class="headerlink" title="2. Redis 常用命令和数据结构"></a>2. Redis 常用命令和数据结构</h2><h3 id="2-1-全局命令"><a href="#2-1-全局命令" class="headerlink" title="2.1 全局命令"></a>2.1 全局命令</h3><p><strong>查看所有键</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> keys *</span></span><br></pre></td></tr></table></figure>

<p><strong>键总数</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> hello world</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> java redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> python redis-py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 插入列表类型</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpush mylist a b c d e f g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dbsize</span></span><br><span class="line">(Integer) 4</span><br></pre></td></tr></table></figure>

<p>dbsize命令的时间复杂度是O（1）。而keys命令会遍历所有键，时间复杂度是O（n）</p>
<p><strong>检查键是否存在</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> exists key</span></span><br></pre></td></tr></table></figure>

<p><strong>删除键</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> del key [key ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>键过期</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加自动删除时间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> expire key seconds</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ttl 返回键的剩余过期时间(正整数)、键没设置过期时间(-1)、键不存在(-2)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ttl key</span></span><br></pre></td></tr></table></figure>

<p><strong>查看键类型</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">type</span> key</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-数据结构与内部编码"><a href="#2-2-数据结构与内部编码" class="headerlink" title="2.2 数据结构与内部编码"></a>2.2 数据结构与内部编码</h3><p>object encoding命令查询内部编码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> object encoding key</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/07/uatJZwhesX6KSqI.png" alt="encoding.png"></p>
<h3 id="2-3-单线程架构"><a href="#2-3-单线程架构" class="headerlink" title="2.3 单线程架构"></a>2.3 单线程架构</h3><p>Redis使用了<strong>单线程架构</strong>：多个客户端的指令进入一个队列执行</p>
<p><strong>单线程，高性能的原因</strong>:  </p>
<ul>
<li>纯内存访问</li>
<li>非阻塞I/O: IO多路复用和自身事件模型</li>
<li>单线程避免了线程切换和竞态产生的消耗</li>
</ul>
<p><strong>缺点</strong>：某个命令执行过长，会造成其他命令的阻塞，只适用于快速执行场景</p>
<h3 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4 字符串"></a>2.4 字符串</h3><p><strong>键</strong>：字符串<br><strong>值</strong>：字符串(string, json, xml)、数字、二进制(图片、音频、视频 –最大512MB)</p>
<h4 id="2-4-1-命令"><a href="#2-4-1-命令" class="headerlink" title="2.4.1 命令"></a>2.4.1 命令</h4><p><strong>设置值</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> key value [ex seconds] [px milliseconds] [nx|xx]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setex key seconds value</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setnx key value</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ex seconds: 为键设置秒级过期时间</li>
<li>px milliseconds：为键设置毫秒级过期时间</li>
<li>nx：键必须不存在,添加</li>
<li>xx: 键必须存在，更新</li>
<li>setex: 作用等同 ex</li>
<li>setnx: 作用等同 nx</li>
</ul>
<p><strong>用setnx(或nx)实现分布式锁</strong>：  </p>
<p><strong>分布式锁</strong>(distributed locks)用来实现不同进程以互斥的方式来共享资源, Redis提供了叫<strong>Redlock</strong>算法</p>
<p>它的实现需要满足三个特性:</p>
<ul>
<li>safety: 互斥性，任何时刻，仅有一个客户端能够持有锁</li>
<li>liveness A: 无死锁，客户端总是能获得锁</li>
<li>liveness B: 容错能力，只要大多数Redis节点运行，客户端总能获得或释放锁</li>
</ul>
<p>以下指令获得分布式锁:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> mykey myvalue NX PX 30000</span></span><br></pre></td></tr></table></figure>

<p><strong>获取值</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> get key</span></span><br></pre></td></tr></table></figure>

<p><strong>批量设置值</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mset key value [key value ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>批量获取值</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mget key [key...]</span></span><br></pre></td></tr></table></figure>

<p><strong>计数</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> incr key</span></span><br></pre></td></tr></table></figure>

<p>对值自增：</p>
<ul>
<li>值非整数，返回错误</li>
<li>值是整数，返回自增结果</li>
<li>键不存在，以0自增，返回1</li>
</ul>
<p>此外，还有 decr（自减）、incrby（自增指定数字）、decrby（自减指定数字）、incrbyfloat（自增浮点数）</p>
<p><strong>追加值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在字符串尾部追加值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> append key value</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串长度</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> strlen key</span></span><br></pre></td></tr></table></figure>

<p><strong>设置并返回原值</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getset key value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> getset hello world</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">$</span><span class="bash"> getset hello redis</span></span><br><span class="line">"world"</span><br></pre></td></tr></table></figure>

<p><strong>设置指定位置的字符</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> offset 偏移值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setrange key offset value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> dx awerome</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setrange dx 3 s</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> get dx</span></span><br><span class="line">"awesome"</span><br></pre></td></tr></table></figure>

<p><strong>获取部分字符串</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getrange key start end</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> getrange dx 3 6</span></span><br><span class="line">"some"</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-内部编码"><a href="#2-4-2-内部编码" class="headerlink" title="2.4.2 内部编码"></a>2.4.2 内部编码</h4><p>字符串内部编码三种：</p>
<ul>
<li>int: 8个字节长整形</li>
<li>embstr: &lt;= 39 bytes的字符串</li>
<li>raw: &gt; 39 bytes的字符串</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> int 型：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> key 8653</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> embstr: 短字符串</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> key <span class="string">"hello,world"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> raw: 长字符串</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> key <span class="string">"dx is an awesome funk boy..."</span></span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-使用场景"><a href="#2-4-3-使用场景" class="headerlink" title="2.4.3 使用场景"></a>2.4.3 使用场景</h4><p><strong>缓存功能</strong></p>
<p>缓存通常能起到加速读写和降低后端压力的作用</p>
<p><img src="https://i.loli.net/2019/12/07/1sIRxycaA2UzuWQ.png" alt="cache.png"></p>
<center>缓存存储架构</center>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪代码</span></span><br><span class="line"><span class="comment">** 获取用户信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先从 Redis 获取用户信息</span></span><br><span class="line">    <span class="comment">// 定义键</span></span><br><span class="line">    String userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">    <span class="comment">// 从 Redis 获取值</span></span><br><span class="line">    String value = redis.get(userRedisKey);</span><br><span class="line">    UserInfo userInfo;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将值反序列化为 UserInfo 并返回</span></span><br><span class="line">        userInfo = deserialize(value);</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有获取到，则从 MySQL 中获取</span></span><br><span class="line">        userInfo = mysql.get(id);</span><br><span class="line">        <span class="comment">// 将 userInfo序列化存入 Redis</span></span><br><span class="line">        <span class="comment">// 添加 1 小时过期时间</span></span><br><span class="line">        redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo))；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：推荐键命名方式：”DB_name: tbl_name: id”</p>
<p><strong>计数</strong></p>
<p>作为视频计数组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incrVedioCounter</span> <span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">    <span class="keyword">return</span> redis.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>共享 Session</strong></p>
<p>由于 <strong>分布式 Web 服务</strong> 会将用户访问 <strong>均衡</strong> 到不同服务器，用户就需要重新登陆。<br>而使用Redis将用户的Session进行集中管理，查询登陆信息即可从 Redis 中获取。</p>
<p><strong>限速</strong></p>
<p>比如手机验证，限制用户每分钟获取验证码频率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String phoneNum = <span class="string">"130........"</span>;</span><br><span class="line">String key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line">isExists = redis.set(key, <span class="number">1</span>, <span class="string">"EX 60"</span>, <span class="string">"NX"</span>);</span><br><span class="line"><span class="comment">// 限制每分钟 5 次</span></span><br><span class="line"><span class="keyword">if</span> (isExists != <span class="keyword">null</span> &amp;&amp; redis.incr(key) &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">//通过</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//限速</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Hash"><a href="#2-5-Hash" class="headerlink" title="2.5 Hash"></a>2.5 Hash</h3><p>在Redis中，Hash 类型是指键值本身又是一个键值对结构，如 value=[[filed1, value1], … [fieldN, valueN]]</p>
<p>哈希类型中的<strong>映射关系</strong>叫作field-value, 不是键 key</p>
<h4 id="2-5-1-命令"><a href="#2-5-1-命令" class="headerlink" title="2.5.1 命令"></a>2.5.1 命令</h4><p><strong>设置值</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hset key filed value</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hset user:1 name tom</span></span><br></pre></td></tr></table></figure>

<p>此外，还有 <code>hsetnx</code></p>
<p><strong>获取值</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hget key field</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hget user:1 name</span></span><br><span class="line">"tom"</span><br></pre></td></tr></table></figure>

<p><strong>删除 field</strong>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hdel key field [field ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>计算 field 个数</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hlen key</span></span><br></pre></td></tr></table></figure>

<p><strong>批量设置或获取</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hmset key filed value [field value ...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hmget key field [field ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>判断 field 是否存在</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexists key field</span></span><br></pre></td></tr></table></figure>

<p><strong>获取所有 field</strong>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hkeys key</span></span><br></pre></td></tr></table></figure>

<p><strong>获取所有 value</strong>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hvals key</span></span><br></pre></td></tr></table></figure>

<p><strong>获取所有 field-value</strong>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hgetall key</span></span><br></pre></td></tr></table></figure>

<p><strong>自增</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hincrby key field</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hincrbyfloat key field</span></span><br></pre></td></tr></table></figure>

<p><strong>计算 value 的字符串长度</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hstrlen key field</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-内部编码"><a href="#2-5-2-内部编码" class="headerlink" title="2.5.2 内部编码"></a>2.5.2 内部编码</h4><ul>
<li><p><strong>ziplist(压缩列表)</strong>：哈希类型元素个数小于<strong>hash-max-ziplist-entries</strong><br>配置（默认512个）、同时所有值都小于<strong>hash-max-ziplist-value</strong>配置（默认64字节）时，Redis会使用ziplist作为哈希的内部实现</p>
</li>
<li><p><strong>hashtable</strong>: 不满足条件时，使用hash表</p>
</li>
</ul>
<p>当field个数超过512或value大于64字节，内部编码会由ziplist变为hashtable：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hmset hashkey f1 v1 f2 v2 f3 v3 ...忽略... f513 v513</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-使用场景"><a href="#2-5-3-使用场景" class="headerlink" title="2.5.3 使用场景"></a>2.5.3 使用场景</h4><p><strong>使用哈希类型缓存用户信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用户 id 作为 key 后缀</span></span><br><span class="line">    userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">    <span class="comment">// hgetall 获取所有用户信息映射关系</span></span><br><span class="line">    userInfoMap = redis.hgetall(userRedisKey);</span><br><span class="line">    UserInfo userInfo;</span><br><span class="line">    <span class="keyword">if</span> (userInfoMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从 MySQL 中获取用户信息</span></span><br><span class="line">        userInfo = mysql.get(id);</span><br><span class="line">        <span class="comment">// 将userInfo变为映射关系使用hmset保存到Redis中</span></span><br><span class="line">        redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));</span><br><span class="line">        <span class="comment">// 添加过期时间</span></span><br><span class="line">        redis.expire(userRedisKey, <span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希类型是稀疏的，而关系型数据库是完全结构化的.</p>
<p>目前三种方法缓存用户信息： </p>
<blockquote>
<p>原生字符串类型：set user:1:name tom</p>
</blockquote>
<ul>
<li>优： 简单直观</li>
<li>缺： 占用过多的键，内存占用量较大，一般不会在生产环境使用。</li>
</ul>
<blockquote>
<p>序列化字符串类型：set user:1 serialize(userInfo)</p>
</blockquote>
<ul>
<li>优：简化编程</li>
<li>缺：有一定开销</li>
</ul>
<blockquote>
<p>哈希类型：hmset user:1 name tom age 23 city beijing</p>
</blockquote>
<ul>
<li>优：简单直观</li>
<li>缺：控制好内部编码转换</li>
</ul>
<h3 id="2-6-列表"><a href="#2-6-列表" class="headerlink" title="2.6 列表"></a>2.6 列表</h3><p>在Redis中，可以对列表两端插入（push）和弹出（pop），最多存储 $2^32-1$ 个元素。两个特点：</p>
<ul>
<li>元素有序，可通过索引获取元素</li>
<li>列表中元素可重复</li>
</ul>
<h4 id="2-6-1-命令"><a href="#2-6-1-命令" class="headerlink" title="2.6.1 命令"></a>2.6.1 命令</h4><p><strong>添加操作</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从右边插入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpush key value [value ...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpush listkey a b c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 左边插入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lpush key value [value ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 向某个元素前或者后插入元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pivot 为参考点元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> linsert key before|after pivot value</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> linsert listkey before b java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange listkey 0 -1</span></span><br><span class="line">"a"</span><br><span class="line">"java"</span><br><span class="line">"b"</span><br><span class="line">"c"</span><br></pre></td></tr></table></figure>

<p><strong>查找</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找指定范围</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrange key start end</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lrange 0 -1命令可以从左到右获取列表的所有元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右到左 -1 到 -N</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表指定索引下标</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lindex key index</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lindex listkey -1</span></span><br><span class="line">"c"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表长度</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> llen key</span></span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从列表左侧弹出元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lpop key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从列表右侧弹出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpop key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定元素</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count &gt; 0, 从左到右删除 count 个</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count &lt; 0, 从右到左删除 count 个</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count=0，删除所有</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lrem key count value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照索引范围修剪列表</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ltrim key start end</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ltrim listkey 1 3</span></span><br></pre></td></tr></table></figure>

<p><strong>修改</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改指定索引下标的元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lset key index newValue</span></span><br></pre></td></tr></table></figure>

<p><strong>阻塞操作</strong>：</p>
<p>阻塞弹出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> blpop key [key ...] timeout</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brpop key [key ...] timeout</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>timeout: 阻塞时间（单位：秒）</p>
</li>
<li><p>列表为空，timeout=0 会一直阻塞直到一个客户端插入元素</p>
</li>
<li><p>如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回</p>
</li>
</ul>
<h4 id="2-6-2-内部编码"><a href="#2-6-2-内部编码" class="headerlink" title="2.6.2 内部编码"></a>2.6.2 内部编码</h4><ul>
<li><p><strong>ziplist</strong>: 同 hash</p>
</li>
<li><p><strong>linkedlist</strong>: 无法满足条件，使用链表</p>
</li>
</ul>
<h4 id="2-6-3-使用场景"><a href="#2-6-3-使用场景" class="headerlink" title="2.6.3 使用场景"></a>2.6.3 使用场景</h4><p><strong>消息队列</strong></p>
<p><img src="https://i.loli.net/2019/12/08/iMbXZv9Rf6BHESL.png" alt="P_C.png"></p>
<p>生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令<br>阻塞式的“抢”列表尾部的元素</p>
<p><strong>文章列表</strong></p>
<ul>
<li><p>每篇文章用 hash 存储</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hmset article:k title yy timestamp 1476512536 contents yyyy</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>向用户文章列表添加</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lpush user:1:articles article:1 article3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash"> lpush user:k:articles article:5</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>分页获取, 用户1的前十篇</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles = lrange user:<span class="number">1</span>:articles <span class="number">0</span> <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> article <span class="keyword">in</span> (articles)</span><br><span class="line">    hgetall(article)</span><br></pre></td></tr></table></figure>
</li>
<li><p>lpush+lpop=Stack（栈）</p>
</li>
<li><p>lpush+rpop=Queue（队列）</p>
</li>
<li><p>lpush+ltrim=Capped Collection（有限集合）</p>
</li>
<li><p>lpush+brpop=Message Queue（消息队列）</p>
</li>
</ul>
<h3 id="2-7-集合"><a href="#2-7-集合" class="headerlink" title="2.7 集合"></a>2.7 集合</h3><p>集合set中<strong>不允许有重复元素</strong>，并且集合中的元素是<strong>无序</strong>的。支持取交集、并集、差集</p>
<h4 id="2-7-1-命令"><a href="#2-7-1-命令" class="headerlink" title="2.7.1 命令"></a>2.7.1 命令</h4><ul>
<li>集合内</li>
</ul>
<p><strong>添加元素</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sadd key element [element ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>删除元素</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> srem key element [element ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>计算元素个数</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scard key</span></span><br></pre></td></tr></table></figure>

<p><strong>判断元素是否在集合中</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sismember key element</span></span><br></pre></td></tr></table></figure>

<p><strong>随机返回指定个数元素</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> srandmember key [count]</span></span><br></pre></td></tr></table></figure>

<p>count 可选，默认1</p>
<p><strong>从集合随机弹出元素</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> spop key [count]</span></span><br></pre></td></tr></table></figure>

<p><strong>获取所有元素</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> smembers key</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集合间(集合 user:1:follow 和 user:2:follow)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sadd user:1:follow it music his sports</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sadd user:2:follow it news her dance</span></span><br><span class="line">``` </span><br><span class="line">**交集**</span><br><span class="line">```Shell</span><br><span class="line"><span class="meta">$</span><span class="bash"> sinter key [key ...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sinter user:1:follow user:2:follow</span></span><br><span class="line">1)"it"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>并集</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sunion key [key ...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sunion user:1:follow user:2:follow</span></span><br><span class="line">1) "his"</span><br><span class="line">2) "news"</span><br><span class="line">3) "music"</span><br><span class="line">4) "her"</span><br><span class="line">5) "sports"</span><br><span class="line">6) "it"</span><br><span class="line">7) "dance"</span><br></pre></td></tr></table></figure>

<p><strong>差集</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sdiff key [key ...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sdiff user:1:follow user:2:follow</span></span><br><span class="line">1) "his"</span><br><span class="line">2) "music"</span><br><span class="line">3) "sports"</span><br><span class="line"><span class="meta">$</span><span class="bash"> sdiff user:2:follow user:1:follow</span></span><br><span class="line">1) "news"</span><br><span class="line">2) "her"</span><br><span class="line">3) "dance"</span><br></pre></td></tr></table></figure>

<p><strong>将交集、并集、差集的结果保存</strong>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sinterstore destination_key key [key ...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> suionstore destination_key key [key ...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sdiffstore destination_key key [key ...]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sdiffstore user:1_2:diff user:1:follow user:2:follow</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-内部编码"><a href="#2-7-2-内部编码" class="headerlink" title="2.7.2 内部编码"></a>2.7.2 内部编码</h4><ul>
<li><strong>intset</strong>(整数集合)：元素为整数且个数小于于set-maxintset-entries配置（默认512个）</li>
<li><strong>hashtable</strong>: 不满足条件，用哈希表</li>
</ul>
<h4 id="2-7-3-使用场景"><a href="#2-7-3-使用场景" class="headerlink" title="2.7.3 使用场景"></a>2.7.3 使用场景</h4><p><strong>标签(tag)</strong></p>
<ul>
<li><p>给用户添加标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sadd user:1:tags tag1 tag2 tag3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sadd user:2:tags tag2 tag4 tag5</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>给标签添加用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sadd tag1:users user:1 user:3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sadd tag2:users user:1 user:2 user:3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户下的标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> srem user:1:tags tag1 tag2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除标签下的用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> srem tag1:users user:1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算用户感兴趣的标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sinter user:1:tags user:2:tags</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-8-有序集合"><a href="#2-8-有序集合" class="headerlink" title="2.8 有序集合"></a>2.8 有序集合</h3><p>与集合不同的是，有序集合给每个元素设置一个分数（score）作为排序的依据，score可以重复，元素不能。</p>
<h4 id="2-8-1-命令"><a href="#2-8-1-命令" class="headerlink" title="2.8.1 命令"></a>2.8.1 命令</h4><ul>
<li>集合内</li>
</ul>
<p><strong>添加成员</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zadd key score member [score member ...]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zadd user:ranking 251 tom</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zadd user:ranking 1 kris 91 mike 200 frank 220 tim 250 martin</span></span><br></pre></td></tr></table></figure>

<p>此外，还有 nx、xx、ch、incr 四个选项</p>
<ul>
<li>ch: 变化的个数</li>
<li>incr：对 score 做增加</li>
</ul>
<p><strong>计算成员个数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zcard key</span></span><br></pre></td></tr></table></figure>

<p><strong>计算某成员分数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zscore key member</span></span><br></pre></td></tr></table></figure>

<p><strong>计算成员的排名</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 分数从低到高</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrank key member</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分数从高到低</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrerank key member</span></span><br></pre></td></tr></table></figure>

<p><strong>删除成员</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zrem key member [member ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>增加成员的分数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zincrby key increment member</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zincrby user:ranking 9 tom</span></span><br><span class="line">"260"</span><br></pre></td></tr></table></figure>

<p><strong>返回指定排名范围的成员</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从低到高</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrange key start end [withscores]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从高到低</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrevrange key start end [withscores]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> withscores 选项同时返回成员的分数</span></span><br></pre></td></tr></table></figure>

<p><strong>返回指定分数范围成员</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zrangebyscore key min max [withscores] [<span class="built_in">limit</span> offset count]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrevrangebyscore key max min [withscores] [<span class="built_in">limit</span> offset count]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrevrangebyscore user:ranking (221 +inf withscores</span></span><br></pre></td></tr></table></figure>

<p>[limit offset count]选项可以限制输出的起始位置和个数<br>min和max还支持开区间（小括号）和闭区间（中括号），-inf 和 +inf分别代表无限小和无限大</p>
<p><strong>返回指定分数范围成员个数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zcount key min max</span></span><br></pre></td></tr></table></figure>

<p><strong>删除指定排名内的升序元素</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zremrangebyrank key start end</span></span><br></pre></td></tr></table></figure>

<p><strong>删除指定分数范围的成员</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zremrangebyscore key min max</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集合间（user:ranking:1 和 user:ranking:2）</li>
</ul>
<p><strong>交集</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>destination: 保存目标键</li>
<li>numkeys: 交集键的个数</li>
<li>key[key …]: 做交集的键</li>
<li>weights weight[weight…]：每个键的权重，默认 1</li>
<li>aggregate sum|min|max：交集后分值的聚合操作，默认 sum</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zinterstore user:ranking:1_inter_2 2 user:ranking:1 user:ranking:2 weights 1 0.5 aggregate max</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrange user:ranking:1_inter_2 0 -1 withscores</span></span><br><span class="line">1) "mike"</span><br><span class="line">2) "91"</span><br><span class="line">3) "martin"</span><br><span class="line">4) "312.5"</span><br><span class="line">5) "tom"</span><br><span class="line">6) "444"</span><br></pre></td></tr></table></figure>

<p><strong>并集</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zunionstore destination numkeys key [key ...] [weights weight [weight ...]]</span></span><br><span class="line">[aggregate sum|min|max]</span><br></pre></td></tr></table></figure>

<h4 id="2-8-2-内部编码"><a href="#2-8-2-内部编码" class="headerlink" title="2.8.2 内部编码"></a>2.8.2 内部编码</h4><ul>
<li><strong>ziplist</strong></li>
<li><strong>skiplist</strong>: 当 ziplist 条件不满足，使用跳跃表</li>
</ul>
<h4 id="2-8-3-使用场景"><a href="#2-8-3-使用场景" class="headerlink" title="2.8.3 使用场景"></a>2.8.3 使用场景</h4><p><strong>排行榜系统</strong></p>
<p>榜单的维度可能是多个方面，比如按照赞数：</p>
<ul>
<li><p>添加用户赞数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mike 上传了一个视频，获得 3 个赞</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zadd user:ranking:2019_12_08 mike 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后再获得一个赞，可以使用zincrby</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zincrby user:ranking:2019_12_08 mike 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取消用户赞数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zrem user:ranking:2019_12_08 mike</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>展示获取赞数最多的十个用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zrevrangebyrank user:ranking:2019_12_08 0 9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>展示用户信息以及用户分数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将用户名作为键后缀，将用户信息保存在哈希类型</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hgetall user:info:mike</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zscore user:ranking:2019_12_08 mike</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zrank user:ranking:2019_12_08 mike</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-9-键管理"><a href="#2-9-键管理" class="headerlink" title="2.9 键管理"></a>2.9 键管理</h3><h4 id="2-9-1-单键管理"><a href="#2-9-1-单键管理" class="headerlink" title="2.9.1 单键管理"></a>2.9.1 单键管理</h4><p><strong>键重命名</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rename key newkey</span></span><br></pre></td></tr></table></figure>

<p>如果 newkey 已经存在，它的值也会被覆盖</p>
<p>renamenx命令，确保只有newkey不存在时候才被覆盖</p>
<p><strong>随机返回一个键</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure>

<p><strong>键过期</strong></p>
<ul>
<li><p>expire key seconds：键在seconds秒后过期。</p>
</li>
<li><p>expireat key timestamp：键在秒级时间戳timestamp后过期。</p>
</li>
<li><p>pexpire key milliseconds：键在milliseconds毫秒后过期。</p>
</li>
<li><p>pexpireat key milliseconds-timestamp键在毫秒级时间戳timestamp后过期。</p>
</li>
<li><p>persist命令可以将键的过期时间清除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> persist key</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串类型键，执行set命令会去掉过期时间</p>
</li>
<li><p>hash、list 没有过期功能</p>
</li>
<li><p>setex命令作为set+expire的组合</p>
</li>
</ul>
<p><strong>迁移键</strong></p>
<p>(1) move</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> move key db</span></span><br></pre></td></tr></table></figure>

<ul>
<li>内部数据库迁移</li>
<li>db 为目标数据库</li>
</ul>
<p>(2) dump + restore</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">source-redis$</span><span class="bash"> dump key</span></span><br><span class="line"><span class="meta">target-redis$</span><span class="bash"> restore key ttl value</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>不同的Redis实例之间进行数据迁移</p>
</li>
<li><p>源 Redis, dump 将键值序列化(RDB格式)</p>
</li>
<li><p>目标 Redis, restore 将序列化复原，ttl 过期时间</p>
</li>
<li><p>迁移非原子性</p>
</li>
</ul>
<p>(3) migrate</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> migrate host port key|<span class="string">""</span> destination-db timeout [copy] [replace] [keys key [key ...]]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>host：目标Redis的IP</p>
</li>
<li><p>port：目标Redis的端口。</p>
</li>
<li><p>key|””：需要迁移多个键，为空字符串””。</p>
</li>
<li><p>destination-db：目标Redis的数据库索引</p>
</li>
<li><p>timeout：迁移的超时时间（单位为毫秒）</p>
</li>
<li><p>[copy]：迁移后不删除源键。</p>
</li>
<li><p>[replace]：迁移进行数据覆盖。</p>
</li>
<li><p>[keys key[key…]]：迁移多个键</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> migrate 127.0.0.1 6380 <span class="string">""</span> 0 5000 keys key1 key2 key3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原子性操作, 首选</p>
</li>
</ul>
<h4 id="2-9-2-遍历键"><a href="#2-9-2-遍历键" class="headerlink" title="2.9.2 遍历键"></a>2.9.2 遍历键</h4><p><strong>全量遍历键</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> keys pattern</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pattern: glob风格的通配符<br>如：keys [user]*</li>
<li>可能会造成Redis阻塞</li>
</ul>
<p><strong>渐进式遍历</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scan cursor [match pattern] [count number]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>cursor是一个游标，第一次遍历从0开始, 之后按照返回的cursor 值再遍历，直到 cursor归零</p>
</li>
<li><p>count number 遍历键个数，默认10</p>
</li>
<li><p>hgetall、smembers、zrange对应的指令为 hscan、sscan、zscan</p>
</li>
</ul>
<p>比如使用 sscan 删除以 old: user 开头的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"myset"</span>;</span><br><span class="line"><span class="comment">// 定义pattern</span></span><br><span class="line">String pattern = <span class="string">"old:user*"</span>;</span><br><span class="line"><span class="comment">// 定义 cursor</span></span><br><span class="line">String cursor = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前扫描结果</span></span><br><span class="line">    ScanResult scanResult = redis.sscan(key, cursor, pattern);</span><br><span class="line">    List elements = scanResult.getResult();</span><br><span class="line">    <span class="keyword">if</span> (elements != <span class="keyword">null</span> &amp;&amp; elements.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 批量删除</span></span><br><span class="line">    redis.srem(key, elements);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取新的游标</span></span><br><span class="line">    cursor = scanResult.getStringCursor();</span><br><span class="line">    <span class="comment">// 如果游标为0表示遍历结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"0"</span>.equals(cursor)) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-9-3-数据库管理"><a href="#2-9-3-数据库管理" class="headerlink" title="2.9.3 数据库管理"></a>2.9.3 数据库管理</h4><p><strong>切换数据库</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> select dbIndex</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>不同于关系型数据库，redis使用数字指定数据库，默认16个（0-15）</p>
</li>
<li><p>默认 0 号数据库</p>
</li>
<li><p>一般不建议多数据库，而使用多 Redis 实例，以接口区分</p>
</li>
</ul>
<p><strong>flushdb/flushall</strong></p>
<p>flushdb只清除当前数据库，flushall会清除所有数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flushall</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">$</span><span class="bash"> dbsize</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">$</span><span class="bash"> select 1</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">$</span><span class="bash"> dbsize</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h2 id="3-多功能"><a href="#3-多功能" class="headerlink" title="3. 多功能"></a>3. 多功能</h2><h3 id="3-1-慢查询分析"><a href="#3-1-慢查询分析" class="headerlink" title="3.1 慢查询分析"></a>3.1 慢查询分析</h3><p>执行一条命令为：</p>
<ul>
<li>发送</li>
<li>排队</li>
<li>执行(慢查询统计时间)</li>
<li>返回</li>
</ul>
<h4 id="3-1-1-配置参数"><a href="#3-1-1-配置参数" class="headerlink" title="3.1.1 配置参数"></a>3.1.1 配置参数</h4><ul>
<li><p>slowlog-log-slower-than：<br>为预设阀值，默认 10000 微秒， 如果执行了超过该值的命令，就会被记录。<br>0 ：记录所有命令<br>&lt; 0: 任何命令都不记录</p>
</li>
<li><p>slowlog-max-len：<br>log 列表的最大长度</p>
</li>
</ul>
<p><strong>两种修改配置的方法</strong>：</p>
<ul>
<li>配置文件</li>
<li>config set 指令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> config <span class="built_in">set</span> slowlog-log-slower-than 20000</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> config <span class="built_in">set</span> slowlog-max-len 1000</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将配置持久化到本地配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> config rewrite</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>获取慢查询日志</strong>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> slowlog get [n]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> slowlog get</span></span><br><span class="line">1)  1) (integer) 665</span><br><span class="line">    2) (integer) 1456718400</span><br><span class="line">    3) (integer) 12006</span><br><span class="line">    4)  1) "SETEX"</span><br><span class="line">        2) "video_info_200"</span><br><span class="line">        3) "300"</span><br><span class="line">        4) "2"</span><br></pre></td></tr></table></figure>

<ul>
<li>n 为获取条数</li>
<li>四部分组成：日志的标识id、发生时间戳、命令耗时、执行命令和参数</li>
</ul>
<p><strong>获取慢查询日志列表当前的长度</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> slowlog len</span></span><br></pre></td></tr></table></figure>

<p><strong>慢查询日志重置</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> slowlog reset</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-配置建议"><a href="#3-1-2-配置建议" class="headerlink" title="3.1.2 配置建议"></a>3.1.2 配置建议</h4><ul>
<li><p>调大列表，线上可设置为1000以上</p>
</li>
<li><p>对于高OPS场景的Redis建议设置为1毫秒</p>
</li>
<li><p>定期执行slowlog get命令将慢查询日志持久化到其他存储中（例如MySQL)</p>
</li>
</ul>
<h3 id="3-2-Redis-Shell"><a href="#3-2-Redis-Shell" class="headerlink" title="3.2 Redis Shell"></a>3.2 Redis Shell</h3><h4 id="3-2-1-redis-cli"><a href="#3-2-1-redis-cli" class="headerlink" title="3.2.1 redis-cli"></a>3.2.1 redis-cli</h4><ul>
<li><p>redis-cli -r(repeat) 次数</p>
</li>
<li><p>redis-cli -i(interval) 秒数</p>
</li>
<li><p>redis-cli -x(标准输入读取数据作为最后一个参数)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"world"</span> | redis-cli -x <span class="built_in">set</span> hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-c(cluster) 连接集群结点</p>
</li>
<li><p>-a(auth) 配置了密码使用</p>
</li>
<li><p>–scan 和 –pattern = scan</p>
</li>
<li><p>–slave 把当前客户端模拟成当前Redis节点的从节点,记录更新操作</p>
</li>
<li><p>–rdb 请求Redis实例生成并发送RDB持久化文件，保存在本地</p>
</li>
<li><p>–bigkeys 使用scan命令对键采样，找到内存占用比较大的键值</p>
</li>
<li><p>–eval 用于执行指定Lua脚本</p>
</li>
<li><p>–latency 测试客户端到目标Redis的网络延迟</p>
</li>
<li><p>–latency-history 分时段的形式显示延迟信息</p>
</li>
<li><p>–latency-dist 统计图表的形式</p>
</li>
<li><p>–stat 实时获取Redis的重要统计信息</p>
</li>
<li><p>–no-raw 要求命令的返回结果必须是原始的格式, –raw相反</p>
</li>
</ul>
<h4 id="3-2-2-redis-server"><a href="#3-2-2-redis-server" class="headerlink" title="3.2.2 redis-server"></a>3.2.2 redis-server</h4><p>除了启动Redis外，还有一个–test-memory选项,检测当前操作系统能否稳定地分配指定容量的内存给Redis</p>
<h4 id="3-2-3-redis-benchmark"><a href="#3-2-3-redis-benchmark" class="headerlink" title="3.2.3 redis-benchmark"></a>3.2.3 redis-benchmark</h4><p>基准性能测试<br>命令选项略</p>
<h3 id="3-3-Pipeline"><a href="#3-3-Pipeline" class="headerlink" title="3.3 Pipeline"></a>3.3 Pipeline</h3><ul>
<li>(1) 发送</li>
<li>(2) 排队</li>
<li>(3) 执行</li>
<li>(4) 返回</li>
</ul>
<p>(1)、(4) 称为 RTT(Round Trip Time 往返时间)</p>
<ul>
<li>Pipeline（流水线）能将一组Redis命令进行组装，通过一次RTT传输给Redis</li>
<li>网络延时越大，Pipeline的效果越明显</li>
<li>Pipeline是非原子的</li>
<li>详见 Jedis</li>
</ul>
<h3 id="3-4-事务与Lua"><a href="#3-4-事务与Lua" class="headerlink" title="3.4 事务与Lua"></a>3.4 事务与Lua</h3><p>为了命令组合的原子性，Redis提供事务功能以及集成Lua脚本</p>
<h4 id="3-4-1-事务"><a href="#3-4-1-事务" class="headerlink" title="3.4.1 事务"></a>3.4.1 事务</h4><ul>
<li>同 SQL 事务，具有 ACID 特性  </li>
<li>multi命令代表事务开始，exec命令代表事务结束</li>
<li>停止事务的执行，可以使用discard命令代替exec命令</li>
<li>Redis并不支持回滚功能</li>
<li>watch key 命令可以在执行事务之前，确保其他客户端没有修改（否则不执行）</li>
</ul>
<h4 id="3-4-2-Lua"><a href="#3-4-2-Lua" class="headerlink" title="3.4.2 Lua"></a>3.4.2 Lua</h4><p>Lua 是一款简单小巧且功能强大的脚本语言</p>
<p><strong>数据类型和处理逻辑</strong></p>
<p>boolean、numbers(数值类型)、strings、tables</p>
<blockquote>
<p>字符串</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> strings hello = <span class="string">"world"</span></span><br><span class="line"><span class="comment">--打印</span></span><br><span class="line"><span class="built_in">print</span>(hello)</span><br></pre></td></tr></table></figure>

<ul>
<li>local 代表局部变量，没有代表全局</li>
</ul>
<blockquote>
<p>数组</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tables myArray = &#123;<span class="string">"redis"</span>, <span class="string">"jedis"</span>, <span class="literal">true</span>, <span class="number">88.0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(myArray[<span class="number">3</span>])</span><br><span class="line"><span class="comment">--true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Lua的数组下标从1开始计算</li>
</ul>
<blockquote>
<p>遍历</p>
</blockquote>
<ul>
<li>for 循环<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> int sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 输出 5050</span></span><br><span class="line"><span class="built_in">print</span>(sum)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 遍历 myArray, #myArray 代表数组长度</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>内置函数 ipairs, 遍历出所有的索引下标和值</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(myArray)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>while</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> int sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> int i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sum = sum + <span class="number">1</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum)</span><br></pre></td></tr></table></figure>
</li>
<li><p>if else</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tables myArray = &#123;<span class="string">"Redis"</span>, <span class="string">"jedis"</span>, <span class="literal">true</span>, <span class="number">88.0</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> myArray[i] == <span class="string">"jedis"</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"true"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">--do nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>hash</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同样使用 tables</span></span><br><span class="line"><span class="keyword">local</span> tables user_1 = &#123;age = <span class="number">28</span>, name = <span class="string">"tom"</span>&#125;</span><br><span class="line"><span class="comment">-- user_1 age is 28</span></span><br><span class="line"><span class="comment">-- .. 拼接两个字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"user_1 age is"</span> .. user_1[<span class="string">"age"</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用内置函数 pairs 遍历</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(user_1)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(key .. value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数定义</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--concat 函数将两个字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span><span class="params">(str1, str2)</span></span></span><br><span class="line">    <span class="keyword">return</span> str1 .. str2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 测试</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">concat</span>(<span class="string">"hello"</span>, <span class="string">"world"</span>))</span><br></pre></td></tr></table></figure>

<p>其他具体参考 <a href="http://www.lua.org/" target="_blank" rel="noopener">官方文档</a></p>
<h4 id="3-4-3-Redis-与-Lua"><a href="#3-4-3-Redis-与-Lua" class="headerlink" title="3.4.3 Redis 与 Lua"></a>3.4.3 Redis 与 Lua</h4><blockquote>
<p>eval</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">eval</span> 脚本内容 key个数 key列表 参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">eval</span> <span class="string">'return "hello " .. KEYS[1] .. ARGV[1]'</span> 1 redis world</span></span><br><span class="line"></span><br><span class="line">"hello redisworld"</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以使用redis-cli –eval直接执行文件。</li>
</ul>
<blockquote>
<p>evalsha</p>
</blockquote>
<ul>
<li>首先<strong>加载脚本</strong>：script load加载到Redis内存中，得到SHA1 校验码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli script load <span class="string">"<span class="variable">$(cat lua_get.lua)</span>"</span></span></span><br><span class="line">"7413dc2440db1fea7c0a0bde841fa68eefaf149c"</span><br></pre></td></tr></table></figure>

<ul>
<li>然后执行脚本<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> evalsha 脚本SHA1值 key个数 key列表 参数列表</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>Lua 的 Redis API</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Lua 中调用 redis.call()</span></span><br><span class="line">redis.call(<span class="string">"set"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">redis.call(<span class="string">"get"</span>, <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> redis 中执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">eval</span> <span class="string">'return redis.call("get", KEYS[1])'</span> 1 hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还可以使用 redis.pall()</li>
</ul>
<h4 id="3-4-4-案例"><a href="#3-4-4-案例" class="headerlink" title="3.4.4 案例"></a>3.4.4 案例</h4><p>三个好处：</p>
<ul>
<li>原子执行</li>
<li>定制命令</li>
<li>命令组合，减少网络开销</li>
</ul>
<p>以下luatest.lua脚本</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对键列表的值做加一操作</span></span><br><span class="line"><span class="keyword">local</span> mylist = redis.call(<span class="string">"lrange"</span>, KEYS[<span class="number">1</span>], <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> index, key <span class="keyword">in</span> <span class="built_in">ipairs</span>(mylist)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    redis.call(<span class="string">"incr"</span>, key)</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli --<span class="built_in">eval</span> luatest.lua hot:user:list</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-5-管理-Lua-脚本"><a href="#3-4-5-管理-Lua-脚本" class="headerlink" title="3.4.5 管理 Lua 脚本"></a>3.4.5 管理 Lua 脚本</h4><p><strong>script load</strong></p>
<p><strong>script exists</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 判断是否已经加载</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scripts exists sha1 [sha1 …]</span></span><br></pre></td></tr></table></figure>

<p><strong>script flush</strong></p>
<p>清除Redis内存已经加载的所有Lua脚本</p>
<p><strong>script kill</strong></p>
<p>杀掉正在执行的Lua脚本</p>
<h3 id="3-5-Bitmaps"><a href="#3-5-Bitmaps" class="headerlink" title="3.5 Bitmaps"></a>3.5 Bitmaps</h3><p>Bitmaps可以实现对位的操作</p>
<h4 id="3-5-1-命令"><a href="#3-5-1-命令" class="headerlink" title="3.5.1 命令"></a>3.5.1 命令</h4><p><strong>设置值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> setbit key offset value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> setbit unique:users:2016-04-05 0 1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> setbit unique:users:2016-04-05 11 1</span></span><br></pre></td></tr></table></figure>

<p>设置键的第offset个位的值（从0算起）</p>
<p><strong>获取值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getbit key offset</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> getbit unique:users:2016-04-05 0</span></span><br><span class="line">(integer)1</span><br></pre></td></tr></table></figure>

<p><strong>获取Bitmaps指定范围值为1的个数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitcount key [start] [end]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitcount unique:users:2016-04-05 0 9</span></span><br><span class="line">(integer)1</span><br></pre></td></tr></table></figure>

<p><strong>Bitmaps间的运算</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destkey key[key....]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>op: 操作，有 and（交集）、or（并集）、not（非）、xor（异或）</p>
</li>
<li><p>destkey: 保存目标键</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 同时计算04-03和04-04都访问过网站的用户</span></span><br><span class="line">bitop and unique:users:and:2016-04-04_03 unique:users:2016-04-03 unique:users:2016-04-04</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>计算Bitmaps中第一个值为targetBit的偏移量</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitpos key targetBit [start] [end]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算2016-04-04当前访问网站的最小用户id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bitpos unique:users:2016-04-04 1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-Bitmaps分析"><a href="#3-5-2-Bitmaps分析" class="headerlink" title="3.5.2 Bitmaps分析"></a>3.5.2 Bitmaps分析</h4><p>bitmaps 适用于活跃用户较多的网站，可节省内存空间</p>
<h3 id="3-6-HyperLogLog"><a href="#3-6-HyperLogLog" class="headerlink" title="3.6 HyperLogLog"></a>3.6 HyperLogLog</h3><ul>
<li>一种基数算法</li>
<li>利用极小的内存空间完成独立总数的统计</li>
</ul>
<p><strong>添加</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pfadd用于向HyperLogLog添加元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pfadd 2016_03_06:unique:ids <span class="string">"uuid-1"</span> <span class="string">"uuid-2"</span> <span class="string">"uuid-3"</span> <span class="string">"uuid-4"</span></span></span><br></pre></td></tr></table></figure>

<p><strong>计算独立用户数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pfcount key [key …]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pfcount 2016_03_06:unique:ids</span></span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<ul>
<li>使用脚本向HyperLogLog插入100万个id<br>,内存只增加了15K左右</li>
<li>存在误差率</li>
</ul>
<p><strong>合并</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pfmerge destkey sourcekey [sourcekey ...]</span></span><br></pre></td></tr></table></figure>

<p>可以求出多个HyperLogLog的并集并赋值给destkey</p>
<h3 id="3-7-发布订阅"><a href="#3-7-发布订阅" class="headerlink" title="3.7 发布订阅"></a>3.7 发布订阅</h3><p>“发布/订阅”模式的消息机制，类似于观察者模式</p>
<h4 id="3-7-1-命令"><a href="#3-7-1-命令" class="headerlink" title="3.7.1 命令"></a>3.7.1 命令</h4><p><strong>发布消息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> publish channel message</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> publish channel:sports <span class="string">"Tim won the championship"</span></span></span><br></pre></td></tr></table></figure>

<p><strong>订阅消息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> subscribe channel [channel ...]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> subscribe channel:sports</span></span><br></pre></td></tr></table></figure>

<p>此时另一个客户端发布消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 客户端2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> publish channel:sports <span class="string">"James won the championship"</span></span></span><br></pre></td></tr></table></figure>

<p>客户端 1 就会接受该消息</p>
<p><strong>取消订阅</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> unsubscribe channel [channel ..]</span></span><br></pre></td></tr></table></figure>

<p><strong>按照模式匹配订阅和取消订阅</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psubscribe pattern [pattern...]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> punsubscribe [pattern [pattern ...]]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> psubscribe it*</span></span><br></pre></td></tr></table></figure>

<p><strong>查询订阅</strong></p>
<p>查看活跃的频道</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pubsub channels [pattern]</span></span><br></pre></td></tr></table></figure>

<p>查看频道订阅数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pubsub numsub [channel ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pubsub numsub channel:sports</span></span><br></pre></td></tr></table></figure>

<p>查看模式订阅数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pubsub numpat</span></span><br></pre></td></tr></table></figure>

<h4 id="3-7-2-使用场景"><a href="#3-7-2-使用场景" class="headerlink" title="3.7.2 使用场景"></a>3.7.2 使用场景</h4><p>聊天室、公告牌、服务之间利用消息解耦</p>
<h3 id="3-8-GEO"><a href="#3-8-GEO" class="headerlink" title="3.8 GEO"></a>3.8 GEO</h3><p>GEO（地理信息定位）功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇</p>
<h4 id="3-8-1-命令"><a href="#3-8-1-命令" class="headerlink" title="3.8.1 命令"></a>3.8.1 命令</h4><p><strong>增加地理位置信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> geoadd key longitube latitube member [longitude latitude member ...]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> geoadd cities:locations 116.28 39.55 beijing</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加多个</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> geoadd cities:locations 117.12 39.08 tianjin 114.29 38.02 shijiazhuang 118.01 39.38 tangshan 115.29 38.51 baoding</span></span><br></pre></td></tr></table></figure>

<p><strong>获取地理位置信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> geopos key member [member ...]</span></span><br></pre></td></tr></table></figure>

<p><strong>获取两个地理位置的距离</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> geodist key member1 member2 [unit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> geodist cities:locations tianjin beijing km</span></span><br><span class="line">"89.2061"</span><br></pre></td></tr></table></figure>

<ul>
<li>unit: 返回结果单位，m, km, mi(miles,英里)，ft(feet,尺)</li>
</ul>
<p><strong>获取指定位置范围内的地理信息位置集合</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> georadiusbymember cities:locations beijing 150 km</span></span><br><span class="line">1) "beijing"</span><br><span class="line">2) "tianjin"</span><br><span class="line">3) "tangshan"</span><br><span class="line">4) "baoding"</span><br></pre></td></tr></table></figure>

<ul>
<li>radius m|km|mi|ft 指明半径</li>
<li>其他参数略</li>
</ul>
<p><strong>获取指定hash</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> geohash key member [member ...]</span></span><br></pre></td></tr></table></figure>

<p>Redis使用geohash将二维经纬度转换为一维字符串</p>
<ul>
<li>GEO的数据类型为zset，geohash存放在zset中。</li>
<li>字符串越长，表示的位置更精确</li>
<li>两个字符串越相似，它们之间的距离越近</li>
</ul>
<p><strong>删除地理位置信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zrem key member</span></span><br></pre></td></tr></table></figure>

<h2 id="4-客户端"><a href="#4-客户端" class="headerlink" title="4. 客户端"></a>4. 客户端</h2><h3 id="4-1-Jedis"><a href="#4-1-Jedis" class="headerlink" title="4.1 Jedis"></a>4.1 Jedis</h3><p>Jedis 是 Java 的客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">            jedis.set(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">            String value = jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数除了可以是字符串，Jedis还提供了字节数组的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] key, <span class="keyword">final</span> <span class="keyword">byte</span>[] value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">get</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] key)</span></span></span><br></pre></td></tr></table></figure>

<p>获取Java对象时,需要将字节数组取出，然后反序列化（使用 protostuff 或 Json 等）</p>
<p><strong>jedis 连接池</strong></p>
<p>生产环境中一般使用连接池的方式对Jedis连接进行管理，而不是直连，每次只需要从Jedis连接池借用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// common-pool连接池配置，这里使用默认配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">    <span class="comment">// 初始化Jedis连接池</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 从连接池获取jedis对象</span></span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="comment">// 2. 执行操作</span></span><br><span class="line">            jedis.get(<span class="string">"hello"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.print(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果使用JedisPool，close操作不是关闭连接，代表归还连接池</span></span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PipeLine</strong></p>
<p>编写 mdel 批量删除方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mdel</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        <span class="comment">// 生成 pipeline 对象</span></span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        <span class="comment">// pipeline 执行命令，注意此时命令并未真正执行</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            pipeline.del(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        pipeline.sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.print(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)&#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行 Lua 脚本</strong></p>
<p>同 redis-cli, Jedis 有三个方法：</p>
<ul>
<li>Object eval(String script, int keyCount, String… params)</li>
<li>Object evalsha(String sha1, int keyCount, String… params)</li>
<li>String scriptLoad(String script)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"hello"</span>;</span><br><span class="line">String script = <span class="string">"return redis.call('get', KEYS[1])"</span>;</span><br><span class="line">Object result = jedis.eval(script, <span class="number">1</span>, key);</span><br><span class="line"><span class="comment">// 打印结果为world</span></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>scriptLoad和evalsha函数要一起使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本加载,SHA1校验和</span></span><br><span class="line">String scriptSha = jedis.scriptLoad(script);</span><br><span class="line"></span><br><span class="line">Stirng key = <span class="string">"hello"</span>;</span><br><span class="line">Object result = jedis.evalsha(scriptSha, <span class="number">1</span>, key);</span><br><span class="line"><span class="comment">// 打印结果为world</span></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<h2 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5. 持久化"></a>5. 持久化</h2><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题</p>
<h3 id="5-1-RDB"><a href="#5-1-RDB" class="headerlink" title="5.1 RDB"></a>5.1 RDB</h3><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程.</p>
<h4 id="5-1-1-触发机制"><a href="#5-1-1-触发机制" class="headerlink" title="5.1.1 触发机制"></a>5.1.1 触发机制</h4><p><strong>手动：save、bgsave</strong></p>
<ul>
<li><p>save: 阻塞服务器，直到完成，线上环境不建议使用</p>
</li>
<li><p>bgsave: 执行fork操作创建子进程持久化，推荐使用</p>
</li>
</ul>
<p><strong>自动触发</strong></p>
<ul>
<li><p>save m n ：表示m秒内数据集存在n次修改时，自动触发bgsave。</p>
</li>
<li><p>从节点执行全量复制操作，主节点自动执行bgsave</p>
</li>
<li><p>debug reload命令重新加载Redis时，自动触发save</p>
</li>
<li><p>执行shutdown命令，触发bgsave</p>
</li>
</ul>
<h4 id="5-1-2-RDB文件的处理"><a href="#5-1-2-RDB文件的处理" class="headerlink" title="5.1.2 RDB文件的处理"></a>5.1.2 RDB文件的处理</h4><p><strong>保存</strong></p>
<p>执行 config set dir {newDir} 和 config set dbfilename {newFileName}</p>
<p><strong>压缩</strong></p>
<p>通过参数 config set rdbcompression {yes|no}动态修改压缩处理</p>
<p><strong>校验</strong></p>
<p>使用Redis提供的redis-check-dump工具检测RDB文件</p>
<h4 id="5-1-3-RDB-优缺点"><a href="#5-1-3-RDB-优缺点" class="headerlink" title="5.1.3 RDB 优缺点"></a>5.1.3 RDB 优缺点</h4><p><strong>优</strong></p>
<ul>
<li><p>压缩的二进制文件、数据快照，适用于备份，全量复制</p>
</li>
<li><p>恢复数据远远快于AOF</p>
</li>
</ul>
<p><strong>缺</strong></p>
<ul>
<li><p>无法实时持久化/秒级持久化，频繁执行成本过高</p>
</li>
<li><p>特定二进制格式，兼容性问题</p>
</li>
</ul>
<h3 id="5-2-AOF"><a href="#5-2-AOF" class="headerlink" title="5.2 AOF"></a>5.2 AOF</h3><p>AOF（append only file）持久化：</p>
<ul>
<li>以独立日志的方式记录每次写命令</li>
<li>重启时再重新执行AOF文件中的命令恢复数据</li>
<li>实时性</li>
</ul>
<h4 id="5-2-1-使用-AOF"><a href="#5-2-1-使用-AOF" class="headerlink" title="5.2.1 使用 AOF"></a>5.2.1 使用 AOF</h4><p>开启AOF：config set appendonly yes<br>设置文件名：config set appendfilename {newFileName}<br>设置目录：config set dir {newDirectory} </p>
<p>工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）</p>
<h4 id="5-2-2-命令写入"><a href="#5-2-2-命令写入" class="headerlink" title="5.2.2　命令写入"></a>5.2.2　命令写入</h4><p>内容直接是文本协议格式, 如 set hello world  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-文件同步"><a href="#5-2-3-文件同步" class="headerlink" title="5.2.3　文件同步"></a>5.2.3　文件同步</h4><p>AOF缓冲区同步文件策略(执行 fsync 的情况）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set appendfsync &#123;always | everysec | no&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化。</li>
<li>配置为everysec，是建议的同步策略，也是默认配置</li>
</ul>
<h4 id="5-2-4-重写"><a href="#5-2-4-重写" class="headerlink" title="5.2.4　重写"></a>5.2.4　重写</h4><p>重写机制把Redis进程内的数据转化为写命令同步到新AOF文件的过程，可压缩文件体积</p>
<ul>
<li>手动触发：直接调用bgrewriteaof命令，fork子进程。</li>
<li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。</li>
</ul>
<h4 id="5-2-4-重启加载"><a href="#5-2-4-重启加载" class="headerlink" title="5.2.4　重启加载"></a>5.2.4　重启加载</h4><p><img src="https://i.loli.net/2019/12/14/DXE3kLAqy4Y5QWm.png" alt="资源 26.png"></p>
<center>Redis持久化文件加载流程</center>

<br>


<h4 id="5-2-5-文件校验"><a href="#5-2-5-文件校验" class="headerlink" title="5.2.5 文件校验"></a>5.2.5 文件校验</h4><p>对于错误格式的AOF文件，先进行备份，然后采用redis-check-aof –fix命令进行修复，修复后使用diff-u对比数据的差异，找出丢失的数据</p>
<h2 id="6-复制"><a href="#6-复制" class="headerlink" title="6. 复制"></a>6. 复制</h2><p>分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡</p>
<h3 id="6-1-配置"><a href="#6-1-配置" class="headerlink" title="6.1 配置"></a>6.1 配置</h3><h4 id="6-1-1-建立复制"><a href="#6-1-1-建立复制" class="headerlink" title="6.1.1 建立复制"></a>6.1.1 建立复制</h4><ul>
<li><p>参与复制的Redis实例划分为主节点（master）和从节点（slave）</p>
</li>
<li><p>复制的数据流是单向的，只能由主节点复制到从节点</p>
</li>
<li><p>三种方法：</p>
</li>
</ul>
<ol>
<li>配置文件中加入slaveof {masterHost} {masterPort}</li>
<li>redis-server启动命令后加入–slaveof {masterHost} {masterPort}</li>
<li>使用命令：slaveof {masterHost} {masterPort}</li>
</ol>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在6380端口执行如下命令</span></span><br><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在6379端口(主节点)写入</span></span><br><span class="line">127.0.0.1:6379&gt; set master slave</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在6380端口(从节点)读取</span></span><br><span class="line">127.0.0.1:6380&gt; get master</span><br><span class="line">"slave"</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 info replication 查看复制信息</li>
</ul>
<h4 id="6-1-2-断开复制"><a href="#6-1-2-断开复制" class="headerlink" title="6.1.2 断开复制"></a>6.1.2 断开复制</h4><p>从节点执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> slaveof no one</span></span><br></pre></td></tr></table></figure>

<ol>
<li>断开与主节点复制关系。</li>
<li>从节点晋升为主节点。</li>
</ol>
<p>切主操作，从节点执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> slaveof &#123;newMasterIp&#125; &#123;newMasterPort&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切主后从节点会清空之前所有的数据</li>
</ul>
<h4 id="6-1-3-安全性"><a href="#6-1-3-安全性" class="headerlink" title="6.1.3 安全性"></a>6.1.3 安全性</h4><ul>
<li><p>主节点设置 requirepass 参数密码验证</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> config <span class="built_in">set</span> requirepass 密码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从节点使用 auth 命令实行校验</p>
</li>
</ul>
<h4 id="6-1-4-传输延迟"><a href="#6-1-4-传输延迟" class="headerlink" title="6.1.4 传输延迟"></a>6.1.4 传输延迟</h4><ul>
<li>低延迟，同机架或同机房部署并关闭repl-disable-tcp-nodelay</li>
<li>高容灾性，同城跨机房部署并开启repl-disable-tcp-nodelay</li>
</ul>
<h3 id="6-2-拓扑"><a href="#6-2-拓扑" class="headerlink" title="6.2 拓扑"></a>6.2 拓扑</h3><p>Redis的复制拓扑结构</p>
<p><strong>一主一从结构</strong></p>
<ul>
<li><p>最简单</p>
</li>
<li><p>用于主节点出现宕机时从节点提供故障转移支持</p>
</li>
<li><p>写命令并发量较高且需要持久化时，可以只在从节点上开启AOF</p>
</li>
<li><p>当主节点关闭持久化且脱机, 从节点上执行<br>slaveof no one断开，再重启主节点</p>
</li>
</ul>
<p><strong>一主多从结构</strong></p>
<ul>
<li><p>星型拓扑结构</p>
</li>
<li><p>适合读占比较大的场景，把读命令发送到从节点来分担主节点压力</p>
</li>
<li><p>慢查询操作，可在其中一台从节点上执行</p>
</li>
<li><p>写并发量较高，消耗带宽</p>
</li>
</ul>
<p><strong>树状主从结构</strong></p>
<ul>
<li><p>树状拓扑结构，层层向下复制</p>
</li>
<li><p>引用中间层，降低主节点负载和传送给从节点的数据量</p>
</li>
<li><p>适合主节点需要挂载多个从节点同时避免对主节点的性能干扰</p>
</li>
</ul>
<h3 id="6-3-原理"><a href="#6-3-原理" class="headerlink" title="6.3 原理"></a>6.3 原理</h3><p><strong>6 个过程</strong>：</p>
<ul>
<li><p>保存主节点（master）信息：<br>地址信息，未连接</p>
</li>
<li><p>主从建立 socket 连接：<br>从节点运行定时任务，建立socket套接字</p>
</li>
<li><p>发送 ping 命令:<br>从节点发送, 检测套接字是否可用, 检测主节点是否可接受处理命令</p>
</li>
<li><p>权限验证:<br>主节点设置了requirepass参数, 从节点必须配置masterauth参数</p>
</li>
<li><p>同步数据集:<br>全量同步和部分同步</p>
</li>
<li><p>命令持续复制:<br>保证主从<br>数据一致性。</p>
</li>
</ul>
<p><strong>数据同步</strong></p>
<p>从节点使用 psync 完成主从数据同步</p>
<ul>
<li><p><strong>全量复制</strong>：一般用于初次场景。全部数据一次性发送给从节点</p>
</li>
<li><p><strong>部分复制</strong>：处理网络闪断等原因造成的数据丢失场景。主节点会补发丢失数据</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psync &#123;runId&#125; &#123;offset&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>runId：从节点所复制主节点的运行id, info server 查看</p>
</li>
<li><p>offset：当前从节点已复制的数据偏移量，通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。</p>
</li>
</ul>
<p><strong>全量复制</strong>  </p>
<ol>
<li>发送psync命令进行数据同步,第一次发送psync-1</li>
<li>主节点解析回复+FULLRESYNC响应全量复制</li>
<li>从节点接收主节点的响应数据保存运行ID和偏移量offset</li>
<li>主节点执行bgsave保存RDB文件到本地</li>
<li>主节点发送RDB文件给从节点, 数据量较大的节点，建议调大repl-timeout参数</li>
<li>在发送 RDB 期间，主节点写命令数据保存在复制客户端缓冲区, 调整client-output-<br>buffer-limit slave配置，</li>
<li>从节点清空自身旧数据</li>
<li>加载RDB文件</li>
<li>开启了AOF, 做bgrewriteaof操作</li>
</ol>
<br>

<p><img src="https://i.loli.net/2019/12/16/eJdH1iMTARu6K9X.png" alt="资源 27.png"></p>
<center>全量复制流程</center>

<br>

<p><strong>部分复制</strong></p>
<p>针对全量复制的过高开销做出的一种优化措施，适用网络闪断或者命令丢失</p>
<p><img src="https://i.loli.net/2019/12/16/KQgXFiNewdxClpW.png" alt="partial replication.png"></p>
<center>部分复制过程</center>

<br>

<ol>
<li>网络出现中断时，超过repl-timeout时间</li>
<li>主节点依然响应命令, 保存复制积压缓冲区</li>
<li>网络恢复后，从节点会再次连上主节点</li>
<li>psync参数发送给主节点，要求进行部分复制操作</li>
<li>偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制</li>
<li>复制积压缓冲区里的数据发送给从节点</li>
</ol>
<h3 id="6-4-问题"><a href="#6-4-问题" class="headerlink" title="6.4 问题"></a>6.4 问题</h3><h4 id="6-4-1-读写分离"><a href="#6-4-1-读写分离" class="headerlink" title="6.4.1 读写分离"></a>6.4.1 读写分离</h4><p>读占比较高的场景，可以通过把一部分读流量分摊到从节点（slave）来减轻主节点（master）压力，可能有以下问题：  </p>
<p><strong>1. 数据延迟</strong></p>
<p><strong>描述</strong>： 由于异步复制特性，主节点的写入数据无法立即在从节点读取。</p>
<p><strong>解决</strong>：编写外部监控程序监听主从节点的复制偏移量</p>
<p><img src="https://i.loli.net/2019/12/16/soaDhGtHcm6BPey.png" alt="monitor.png"></p>
<br>


<ol>
<li><p>监控程序（monitor）定期检查主从节点的偏移量（info replication命令，主：master_repl_offset 记录， 从：主节点的slave0字段的offset指标），差值为延迟字节量</p>
</li>
<li><p>延迟字节量超过一定阀值，触发报警并通知客户端</p>
</li>
<li><p>修改读命令路由到其他从节点或主节点上</p>
</li>
</ol>
<p><strong>2. 读到过期数据</strong></p>
<p><strong>解决</strong>：维护过期数据删除策略，分两种</p>
<p><strong>惰性删除</strong>：主节点每次处理读取命令时，都会检查键是否超时，如果超时则执行del命令删除键对象，之后del命令也会异步发送给从节点</p>
<p><strong>定时删除</strong>：主节点在内部定时任务会循环采样一定数量的键，当发现采样的键过期时执行del命令</p>
<p><strong>3. 从节点故障问题</strong></p>
<p><strong>解决</strong>：立刻切换到其他从节点或主节点</p>
<p>综上，读写分离维护成本较高，可以考虑使用 Redis Cluster等分布式解决方案</p>
<h4 id="6-4-2-规避全量复制"><a href="#6-4-2-规避全量复制" class="headerlink" title="6.4.2 规避全量复制"></a>6.4.2 规避全量复制</h4><ul>
<li><p><strong>第一次建立复制</strong>：无法避免</p>
</li>
<li><p><strong>节点运行ID不匹配</strong>：主节点因故障重启，它的运行ID会改变。此时手动提升从节点为主节点或者采用支持自动故障转移的哨兵或集群方案</p>
</li>
<li><p><strong>复制积压缓冲区不足</strong>：出现在部分复制请求中，增大积压缓冲区，保证repl_backlog_size&gt;net_break_time*write_size_per_minute</p>
</li>
</ul>
<h4 id="6-4-3-规避复制风暴"><a href="#6-4-3-规避复制风暴" class="headerlink" title="6.4.3 规避复制风暴"></a>6.4.3 规避复制风暴</h4><p><strong>复制风暴</strong>是指<strong>大量从节点</strong>对同一主节点或者对同一台机器的多个主节点短时间内发起<strong>全量复制</strong>的过程。</p>
<p><strong>解决</strong>：</p>
<ol>
<li><strong>单主节点复制风暴</strong>：  </li>
</ol>
<p><strong>描述</strong>： 主节点挂载多个从节点，主节点重启，同时向多个从节点发送RDB快照<br><strong>解决</strong>： 减少挂载从节点（slave）的数量，或者采用树状复制结构</p>
<ol start="2">
<li><strong>单机器复制风暴</strong>：  </li>
</ol>
<p><strong>描述</strong>： 一台机器（machine）上同时部署多个主节点时<br><strong>解决</strong>： 主节点尽量分散在多台机器或提供故障转移机制</p>
<h2 id="7-哨兵-Sentinel"><a href="#7-哨兵-Sentinel" class="headerlink" title="7. 哨兵(Sentinel)"></a>7. 哨兵(Sentinel)</h2><p>Redis Sentinel是Redis的<strong>高可用</strong>实现方案</p>
<h3 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h3><h4 id="7-1-1-主从复制的问题"><a href="#7-1-1-主从复制的问题" class="headerlink" title="7.1.1 主从复制的问题"></a>7.1.1 主从复制的问题</h4><ul>
<li><p><strong>高可用问题</strong>：主节点出现故障，需要手动将一个从节点晋升为主节点，整个故障转移过程都需要人工干预</p>
</li>
<li><p><strong>分布式问题</strong>：主节点的写能力受到单机的限制</p>
</li>
<li><p><strong>分布式问题</strong>：主节点的存储能力受到单机的限制</p>
</li>
</ul>
<h4 id="7-1-2-Redis-Sentinel的高可用性"><a href="#7-1-2-Redis-Sentinel的高可用性" class="headerlink" title="7.1.2 Redis Sentinel的高可用性"></a>7.1.2 Redis Sentinel的高可用性</h4><p>当主节点出现故障时，Redis Sentinel能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。</p>
<ul>
<li><p>Redis Sentinel 包含若干个Sentinel节点和Redis数据节点（主从结点）</p>
</li>
<li><p>每个Sentinel节点会对其余节点进行监控，发现节点不可达时，会对节点做下线标识</p>
</li>
<li><p>标识的是主节点，所有Sentinel节点“协商”选举出一个Sentinel节点作为领导者结点做故障转移</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/12/17/qwF3s6G4zSpYDtP.png" alt="sentinel.png"></p>
<p>假设主节点故障，选出 sentinel-2 作为领导者结点，故障转移为以下四个步骤：</p>
<p><img src="https://i.loli.net/2019/12/17/Aq7iCrb5coPpzkm.png" alt="故障转移0.png"></p>
<ol>
<li><p>主节点出现故障，从节点（slave-1）执行slaveof no one命令使其成为新的主节点</p>
</li>
<li><p>通知客户端，重新启动</p>
</li>
<li><p>客户端命令另一个从节点（slave-2）去复制新的主节点（new-master）</p>
</li>
<li><p>原来的主节点恢复后，让它去复制新的主节点</p>
</li>
</ol>
<p>转移后的拓扑结构：</p>
<p><img src="https://i.loli.net/2019/12/17/ntPO5hrFNSXTE2Q.png" alt="故障转移2.png"></p>
<h3 id="7-2-安装部署"><a href="#7-2-安装部署" class="headerlink" title="7.2 安装部署"></a>7.2 安装部署</h3><p>以3个Sentinel节点、1个主节点、2个从节点组成一个RedisSentinel为例</p>
<table border="1">
    <caption>物理结构</caption>
    <tr>
        <th>角色</th>
        <th>ip</th>
        <th>port</th>
    </tr>
    <tr>
        <td>master</td>
        <td>127.0.0.1</td>
        <td>6379</td>
    </tr>
    <tr>
        <td>slave-1</td>
        <td>127.0.0.1</td>
        <td>6380</td>
    </tr>
    <tr>
        <td>slave-2</td>
        <td>127.0.0.1</td>
        <td>6381</td>
    </tr>
    <tr>
        <td>sentinel-1</td>
        <td>127.0.0.1</td>
        <td>26379</td>
    </tr>
    <tr>
        <td>sentinel-2</td>
        <td>127.0.0.1</td>
        <td>26380</td>
    </tr>
    <tr>
        <td>sentinel-3</td>
        <td>127.0.0.1</td>
        <td>26381</td>
    </tr>
</table>


<p><strong>通过配置文件启动主节点和从节点</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis-6379.conf</span><br><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6379.log"</span><br><span class="line">dbfilename "dump-6379.rdb"</span><br><span class="line">dir "./redis/data"</span><br><span class="line"></span><br><span class="line">redis-6380.conf</span><br><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6380.log"</span><br><span class="line">dbfilename "dump-6380.rdb"</span><br><span class="line">dir "./redis/data"</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line">redis-6381.conf</span><br><span class="line">port 6381</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6381.log"</span><br><span class="line">dbfilename "dump-6381.rdb"</span><br><span class="line">dir "./redis/data"</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server redis-6379.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server redis-6380.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server redis-6381.conf</span></span><br></pre></td></tr></table></figure>

<p><strong>配置Sentinel节点</strong>:  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-26379.conf</span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "26379.log"</span><br><span class="line">dir ./redis/data</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sentinel monitor mymaster 127.0.0.1 6379 2配置代表sentinel-1节点需要监控127.0.0.1：6379这个主节点，2代表判断主节点失败至少需要2个Sentinel节<br>点同意, 可设置不同的主节点名监控多主结点</p>
</li>
<li><p>超过了down-after-milliseconds配置的时间（单位为毫秒）且没有有效的回复，则判定节点不可达</p>
</li>
<li><p>parallel-syncs 用来限制在一次故障转移之后，每次向新的主节点发起复制操作的从节点个数</p>
</li>
<li><p>failover-timeout通常被解释成故障转移超时时间</p>
</li>
<li><p>sentinel auth-pass配置通过添加主节点的密码</p>
</li>
</ul>
<p><strong>启动Sentinel节点</strong></p>
<ul>
<li><p>方法一：使用redis-sentinel命令  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二: 使用redis-server命令加–sentinel参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-sentinel-26379.conf --sentinel</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>info Sentinel</code> 可查看相关信息</p>
<ul>
<li>建议Redis Sentinel的所有节点应该分布在不同的物理机</li>
</ul>
<h3 id="7-3-API"><a href="#7-3-API" class="headerlink" title="7.3 API"></a>7.3 API</h3><blockquote>
<p><strong>sentinel masters</strong>: 展示所有被监控的主节点状态以及相关的统计信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379$ sentinel masters</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sentinel master &lt;master name&gt;</strong>: 展示指定&lt;master name&gt;的主节点状态以及相关的统计信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379$ sentinel master mymaster-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sentinel slaves &lt;master name&gt;</strong>: 从节点状态以及相关的统计信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379$ sentinel slaves mymaster-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sentinel sentinels &lt;master name&gt;</strong>: 展示指定<master name>的Sentinel节点集合</master></p>
</blockquote>
<blockquote>
<p><strong>sentinel reset &lt;pattern&gt;</strong>: 对符合 &lt;pattern&gt;（通配符风格）主节点的配置进行重置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379$ sentinel reset mymaster-1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sentinel failover &lt;master name&gt;</strong>: 对指定&lt;master name&gt;主节点进行强制故障转移(没有“协商”)</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379$ sentinel failover mymaster-2</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sentinel ckquorum &lt;master name&gt;</strong>: 检测当前可达的Sentinel节点总数是否达到<quorum>的个数</quorum></p>
</blockquote>
<blockquote>
<p><strong>sentinel flushconfig</strong>: 将Sentinel节点的配置强制刷到磁盘上</p>
</blockquote>
<blockquote>
<p><strong>sentinel remove &lt;master name&gt;</strong>: 取消当前Sentinel节点对于指定&lt;master name&gt;主节点的监控</p>
</blockquote>
<h3 id="7-4-客户端连接"><a href="#7-4-客户端连接" class="headerlink" title="7.4 客户端连接"></a>7.4 客户端连接</h3><p><strong>基本步骤</strong>：</p>
<ul>
<li>遍历Sentinel节点集合获取一个可用的Sentinel节点</li>
<li>通过sentinel get-master-addr-by-name master-name这个API来获取对应主节点的相关信息</li>
<li>验证当前获取的“主节点”是真正的主节点(info replication)</li>
<li>客户端订阅Sentinel节点相关频道</li>
</ul>
<p><strong>Java 操作 redis sentinel</strong></p>
<p>Jedis针对Redis Sentinel给出了一个JedisSentinelPool</p>
<p>初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 日志类</span></span><br><span class="line">        Logger logger = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Sentinel节点集合</span></span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// common-pool连接池配置</span></span><br><span class="line">        GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">        <span class="comment">// 读写,连接超时</span></span><br><span class="line">        <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 主节点名 myMaster</span></span><br><span class="line">        JedisSentinelPool jedisSentinelPool = <span class="keyword">new</span> JedisSentinelPool(<span class="string">"myMaster"</span>, sentinels, poolConfig, timeout);</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisSentinelPool.getResource();</span><br><span class="line">            <span class="comment">// jedis command</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-实现原理"><a href="#7-5-实现原理" class="headerlink" title="7.5 实现原理"></a>7.5 实现原理</h3><p><strong>1. 三个定时监控任务</strong></p>
<ol>
<li><p>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构</p>
</li>
<li><p>每隔2秒，每个Sentinel节点会向Redis数据节点的<strong>sentinel</strong>：hello<br>频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息</p>
</li>
<li><p>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测</p>
</li>
</ol>
<p><strong>2. 客观下线与主观下线</strong></p>
<p><strong>主观下线（+sdown）</strong><br>心跳检测时，节点超过 down-after-milliseconds 没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线</p>
<p><strong>客观下线（+odown）</strong><br>当Sentinel主观下线的节点是主节点时，协商通过（sentinel is-master-<br>down-by-addr命令）</p>
<p><strong>3. 领导者Sentinel节点选举</strong></p>
<ul>
<li><p>每个在线的Sentinel节点，向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者</p>
</li>
<li><p>如果某Sentinel节点票数大于等于max（quorum，num（sentinels）/2+1），它就成为领导者节点</p>
</li>
</ul>
<p><strong>4. 故障转移</strong></p>
<p>领导者选举出的Sentinel节点负责故障转移：</p>
<ul>
<li>在从节点列表中选出一个节点作为新的主节点（过滤）</li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/EelgUSTZjc7FGpD.png" alt="选出替代主节点.png"></p>
<ul>
<li><p>对从节点执行slaveof no one</p>
</li>
<li><p>让其余从节点成为新主节点的从节点</p>
</li>
<li><p>将原来的主节点更新为从节点</p>
</li>
</ul>
<h3 id="7-6-高可用读写分离"><a href="#7-6-高可用读写分离" class="headerlink" title="7.6 高可用读写分离"></a>7.6 高可用读写分离</h3><p><img src="https://i.loli.net/2019/12/18/X1KepagWdZf7Ak2.png" alt="读写分离模型1.png"></p>
<center>一般读写分离模型</center>

<br>

<p>上述模型中，从节点不是高可用的:</p>
<ul>
<li>如果slave-1节点出现故障，客户端client-1将与其失联，</li>
<li>Sentinel节点只会对该节点做主观下线(故障转移是针对主节点)</li>
</ul>
<p><strong>Redis Sentinel读写分离设计思路</strong>:</p>
<p>从节点变动的事件消息：</p>
<ul>
<li>+switch-master：切换主节点（原来的从节点晋升为主节点）</li>
<li>+convert-to-slave：切换从节点（原来的主节点降级为从节点）</li>
<li>+sdown：主观下线</li>
<li>+reboot：重新启动了某个节点</li>
</ul>
<p>只要能够实时掌握所有从节点的状态，把所有从节点看做一个资源池，无论是上线还是下线从节点，客户端都能及时感知到</p>
<p><img src="https://i.loli.net/2019/12/18/rfAtdL5HWhBeYmQ.png" alt="读写分离模型2.png"></p>
<center>Redis Sentinel下的读写分离架构</center>

<h2 id="8-集群"><a href="#8-集群" class="headerlink" title="8. 集群"></a>8. 集群</h2><p>分布式解决方案，当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的</p>
<h3 id="8-1-数据分布"><a href="#8-1-数据分布" class="headerlink" title="8.1 数据分布"></a>8.1 数据分布</h3><p><strong>数据分布理论</strong></p>
<p><img src="https://i.loli.net/2019/12/18/qdRNDXKe4Jg57Z8.png" alt="资源 37.png"></p>
<p>常见的<strong>分区规则</strong>有<strong>哈希分区</strong>和<strong>顺序分区</strong>两种，而于Redis Cluster采用哈希分区规则</p>
<p>常见的哈希分区规则有：</p>
<ul>
<li><p><strong>节点取余分区</strong>：hash（key）% N 计算出哈希值(N 为节点数)。当节点数量变化时，需要重新计算</p>
</li>
<li><p><strong>一致性哈希分区</strong>：为系统中每个节点分配一个token，范围一般在0~$2^32$，这些token构成一个哈希环。查找时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点</p>
</li>
<li><p><strong>虚拟槽分区</strong>：redis cluster 采用，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot），每个节点会负责一定数量的槽</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/OL4pTU2mrw8ICJq.png" alt="虚拟槽分区.png"></p>
<p><strong>Redis 数据分区</strong></p>
<p>Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot = CRC16（key）&amp; 16383</p>
<p><strong>集群功能限制</strong></p>
<ul>
<li><p>key批量操作支持有限，目前只支持具有相同slot值的key执行批量操作</p>
</li>
<li><p>key事务操作支持有限，只支持多key在同一节点上的事务操作</p>
</li>
<li><p>key作为数据分区的最小粒度</p>
</li>
<li><p>不支持多数据库空间，只能使用一个数据库空间，即db0</p>
</li>
<li><p>复制结构只支持一层，从节点只能复制主节点</p>
</li>
</ul>
<h3 id="8-2-搭建集群"><a href="#8-2-搭建集群" class="headerlink" title="8.2 搭建集群"></a>8.2 搭建集群</h3><ol>
<li>准备节点</li>
</ol>
<p>节点数量至少为6个，建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。</p>
<p>配置如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点超时时间，单位毫秒</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群内部配置文件</span></span><br><span class="line">cluster-config-file "nodes-6379.conf"</span><br></pre></td></tr></table></figure>

<p>配置文件命名规则redis-{port}.conf</p>
<p>启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6379.conf</span><br><span class="line">redis-server conf/redis-6380.conf</span><br><span class="line">redis-server conf/redis-6381.conf</span><br><span class="line">redis-server conf/redis-6382.conf</span><br><span class="line">redis-server conf/redis-6383.conf</span><br><span class="line">redis-server conf/redis-6384.conf</span><br></pre></td></tr></table></figure>

<p>启动成功，第一次启动时如果没有集群配置文件，自动创建，名称采用cluster-config-file参数项控制，建议采用node-{port}.conf格式自定义</p>
<ol start="2">
<li>节点握手</li>
</ol>
<p>节点握手是集群彼此通信的第一步，由客户端发起命令：cluster meet {ip} {port}</p>
<ul>
<li><p>节点6379本地创建6380节点信息对象，并发送meet消息</p>
</li>
<li><p>节点6380接受到meet消息后，保存6379节点信息并回复pong消息</p>
</li>
<li><p>节点6379和6380彼此定期通过ping/pong消息进行正常的节点通信。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/12/19/IdNXEhbcZSl19Pu.png" alt="cluster1.png"></p>
<center>通过两个节点握手的集群结构</center>

<p>加入其他节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379$ cluster meet 127.0.0.1 6381</span><br><span class="line">127.0.0.1:6379$ cluster meet 127.0.0.1 6382</span><br><span class="line">127.0.0.1:6379$ cluster meet 127.0.0.1 6383</span><br><span class="line">127.0.0.1:6379$ cluster meet 127.0.0.1 6384</span><br></pre></td></tr></table></figure>

<ul>
<li>cluster nodes命令获取集群节点状态</li>
<li>cluster info命令可以获取集群当前状态</li>
</ul>
<p><img src="https://i.loli.net/2019/12/19/3ZS6CUtHE5ALf7F.png" alt="cluster4.png"></p>
<center>集群握手完成后的状态</center>

<ol start="3">
<li>分配槽</li>
</ol>
<p>通过cluster addslots命令为节点分配槽。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923...16383&#125;</span></span><br></pre></td></tr></table></figure>

<p>集群模式下，Reids节点角色分为主节点和从节点，首次启动的节点和被分配槽的节点都是主节点<br>使用<code>cluster replicate {nodeId}</code>命令让一个节点成为从节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6382$ cluster replicate cfb28ef1deee4e0fa78da86abe5d24566744411e</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6383$ cluster replicate 8e41673d59c9568aa9d29fb174ce733345b3e8f1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6384$ cluster replicate 40b8d09d44294d2e23c7c768efc8fcd153446746</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/19/VK96IkJFPwgH1nm.png" alt="cluster.png"></p>
<center>集群完整结构</center>

<p>此外也可用redis-trib.rb脚本搭建集群</p>
<h3 id="8-3-节点通信"><a href="#8-3-节点通信" class="headerlink" title="8.3 节点通信"></a>8.3 节点通信</h3><ul>
<li>Redis集群采用P2P的Gossip（流言）协议维护元数据(如节点负责哪些数据，是否出现故障等状态信息)  </li>
<li>Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播</li>
</ul>
<p><strong>Gossip消息</strong></p>
<p>信息交换的载体是节点彼此发送的Gossip消息，可分为：ping消息、pong消息、meet消息、fail消息</p>
<ul>
<li>meet消息：用于通知新节点加入</li>
<li>ping消息：集群内交换最频繁的消息，检测节点是否在线和交换彼此状态信息</li>
<li>pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信</li>
<li>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息</li>
</ul>
<p>所有的消息格式划分为：消息头和消息体</p>
<p><img src="https://i.loli.net/2019/12/19/hq65RyD27v4YsBL.png" alt="消息解析.png"></p>
<center>消息解析流程</center>

<br>

<p><strong>节点选择</strong></p>
<ul>
<li><p>通信节点选择过多虽然可以做到信息及时交换但成本过高</p>
</li>
<li><p>节点选择过少会降低集群内所有节点彼此信息交换频率，从而影响故障判定、新节点发现等需求的速度</p>
</li>
</ul>
<p>选择发送消息的节点数量：  </p>
<ul>
<li><p>每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息</p>
</li>
<li><p>每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster_node_timeout/2，则立刻发送ping消息</p>
</li>
<li><p>因此，每个节点每秒需要发送ping消息的数量=1+10*num（node.pong_received&gt;cluster_node_timeout/2）</p>
</li>
</ul>
<h3 id="8-4-集群伸缩"><a href="#8-4-集群伸缩" class="headerlink" title="8.4 集群伸缩"></a>8.4 集群伸缩</h3><p>Redis集群提供了灵活的节点扩容和收缩方案，实现对节点的灵活上下线控制。本质上抽象为槽和对应数据在不同节点之间灵活移动</p>
<h4 id="8-4-1-扩容集群"><a href="#8-4-1-扩容集群" class="headerlink" title="8.4.1 扩容集群"></a>8.4.1 扩容集群</h4><ol>
<li>准备新节点<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6385.conf</span><br><span class="line">redis-server conf/redis-6386.conf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>启动后的新节点作为孤儿节点运行</p>
<ol start="2">
<li>加入集群<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379$ cluster meet 127.0.0.1 6385</span><br><span class="line">127.0.0.1:6379$ cluster meet 127.0.0.1 6386</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>新节点刚开始都是主节点状态, 后续操作有两种选择：</p>
<ul>
<li>为它迁移槽和数据实现扩容</li>
<li>作为其他主节点的从节点负责故障转移</li>
</ul>
<p>redis-trib.rb工具也实现了为现有集群添加新节点的命令,推荐使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb add-node 127.0.0.1:6385 127.0.0.1:6379</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb add-node 127.0.0.1:6386 127.0.0.1:6379</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>迁移槽和数据</li>
</ol>
<p>槽在迁移过程中集群可以正常提供读写服务</p>
<p><strong>槽迁移计划</strong></p>
<p>槽是Redis集群管理数据的基本单位，迁移计划需要确保每个节点负责相似数量的槽，从而保证各节点的数据均匀</p>
<p><strong>迁移数据</strong></p>
<ul>
<li><p>对目标节点发送 <code>cluster setslot {slot} importing {sourceNodeId}</code> 命令，让目标节点准备导入槽的数据。</p>
</li>
<li><p>对源节点发送 <code>cluster setslot {slot} migrating {targetNodeId}</code> 命令，让源节点准备迁出槽的数据</p>
</li>
<li><p>源节点循环执行 <code>cluster getkeysinslot {slot} {count}</code>命令，获取count个属于槽{slot}的键。</p>
</li>
<li><p>在源节点上执行 <code>migrate {targetIp} {targetPort} &quot;&quot; 0 {timeout} keys {keys...}</code></p>
</li>
<li><p>向集群内所有主节点发送<code>cluster setslot {slot} node {targetNodeId}</code>命令，通知槽分配给目标节点</p>
</li>
</ul>
<p>redis-trib也提供了槽重分片功能</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb reshard host:port --from &lt;arg&gt; --to &lt;arg&gt; --slots &lt;arg&gt; --yes --timeout</span><br><span class="line">&lt;arg&gt; --pipeline &lt;arg&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>host：port：必传参数，集群内任意节点地址，用来获取整个集群信息。  </li>
</ul>
<p>我们迁移 6385 端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb reshard 127.0.0.1:6379</span></span><br></pre></td></tr></table></figure>

<p><strong>添加从节点</strong><br><code>cluster replicate {masterNodeId}</code>命令为主节点添加对应从节点</p>
<p>把节点6386作为6385的从节点</p>
<h4 id="8-4-2-收缩集群"><a href="#8-4-2-收缩集群" class="headerlink" title="8.4.2 收缩集群"></a>8.4.2 收缩集群</h4><p><img src="https://i.loli.net/2019/12/19/ldoPD2vxnNVKGrg.png" alt="收缩.png"></p>
<center>节点安全下线流程</center>

<p><strong>下线迁移槽</strong></p>
<p>把6381和6384节点下线，6381是主节点，负责槽（12288-16383），共 4096 个槽</p>
<p>和扩容迁移方向相反，直接使用<code>redis-trib.rb reshard</code>命令完成槽迁移，执行3次reshard命令，分别迁移1365、1365、1366个槽</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb reshard 127.0.0.1:6381</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb reshard 127.0.0.1:6381</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb reshard 127.0.0.1:6381</span></span><br></pre></td></tr></table></figure>

<p><strong>忘记节点</strong></p>
<p>让其他节点不再与下线节点进行Gossip消息交换，Redis 提供了 <code>cluster forget {downNodeId}</code> 命令实现该功能</p>
<p>线上环境建议使用 <code>redis-trib.rb del-node {host：port} {downNodeId}</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb del-node 127.0.0.1:6379 4fa7eac4080f0b667ffeab9b87841da49b84a6e4 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从节点6384 id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-trib.rb del-node 127.0.0.1:6379 40b8d09d44294d2e23c7c768efc8fcd153446746 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主节点6381 id</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-请求路由"><a href="#8-5-请求路由" class="headerlink" title="8.5 请求路由"></a>8.5 请求路由</h3><h4 id="8-5-1-请求重定向"><a href="#8-5-1-请求重定向" class="headerlink" title="8.5.1 请求重定向"></a>8.5.1 请求重定向</h4><p>Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复 MOVED重定向错误<br><code>cluster keyslot {key}</code> 命令返回key所对应的槽, 使用redis-cli命令时，可以加入-c参数支持自动重定向</p>
<h4 id="8-5-2-Smart客户端"><a href="#8-5-2-Smart客户端" class="headerlink" title="8.5.2 Smart客户端"></a>8.5.2 Smart客户端</h4><p><strong>JedisCluster的定义</strong></p>
<p>Jedis为Redis Cluster提供了Smart客户端，对应的类是JedisCluster, 初始化方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JedisCluster</span><span class="params">(Set&lt;HostAndPort&gt; jedisClusterNode, <span class="keyword">int</span> connectionTimeout, <span class="keyword">int</span> soTimeout, <span class="keyword">int</span> maxAttempts, <span class="keyword">final</span> GenericObjectPoolConfig poolConfig)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Set<hostandport>jedisClusterNode：所有Redis Cluster节点信息</hostandport></li>
<li>int connectionTimeout：连接超时</li>
<li>int soTimeout：读写超时</li>
<li>int maxAttempts：重试次数</li>
<li>GenericObjectPoolConfig poolConfig：连接池参数，JedisCluster会为 Redis Cluster的每个节点创建连接池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化所有节点(例如6个节点)</span></span><br><span class="line">Set&lt;HostAndPort&gt; jedisClusterNode = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"10.10.xx.1"</span>, <span class="number">6379</span>));</span><br><span class="line">jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"10.10.xx.2"</span>, <span class="number">6379</span>));</span><br><span class="line">jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"10.10.xx.3"</span>, <span class="number">6379</span>));</span><br><span class="line">jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"10.10.xx.4"</span>, <span class="number">6379</span>));</span><br><span class="line">jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"10.10.xx.5"</span>, <span class="number">6379</span>));</span><br><span class="line">jedisClusterNode.add(<span class="keyword">new</span> HostAndPort(<span class="string">"10.10.xx.6"</span>, <span class="number">6379</span>));</span><br><span class="line"><span class="comment">// 初始化commnon-pool连接池，并设置相关参数</span></span><br><span class="line">GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line"><span class="comment">// 初始化JedisCluster</span></span><br><span class="line">JedisCluster jedisCluster = <span class="keyword">new</span> JedisCluster(jedisClusterNode, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">5</span>, poolConfig);</span><br></pre></td></tr></table></figure>

<ul>
<li>不需要管理连接池的借还，它在内部已<br>经完成</li>
<li>不要执行close（）操作，它会将所有JedisPool执行 destroy操作。</li>
</ul>
<p><strong>多节点命令和操作</strong><br>有些命令或者操作，诸如keys、flushall、删除指定模式的键，需要遍历所有节点才可以完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从RedisCluster批量删除指定pattern的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delRedisClusterByPattern</span><span class="params">(JedisCluster jedisCluster, String pattern, <span class="keyword">int</span> scanCounter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有节点的JedisPool</span></span><br><span class="line">    Map&lt;String, JedisPool&gt; jedisPoolMap = jedisCluster.getClusterNodes();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, JedisPool&gt; entry : jedisPoolMap.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 获取每个节点的Jedis连接</span></span><br><span class="line">        Jedis jedis = entry.getValue().getResource();</span><br><span class="line">        <span class="comment">// 只删除主节点数据</span></span><br><span class="line">        <span class="keyword">if</span> (!isMaster(jedis)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用Pipeline每次删除指定前缀的数据</span></span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        <span class="comment">// 使用scan扫描指定前缀的数据</span></span><br><span class="line">        String cursor = <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">// 指定扫描参数：每次扫描个数和pattern</span></span><br><span class="line">        ScanParams params = <span class="keyword">new</span> ScanParams().count(scanCounter).match(pattern);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行扫描</span></span><br><span class="line">            ScanResult&lt;String&gt; scanResult = jedis.scan(cursor, params);</span><br><span class="line">            <span class="comment">// 删除的key列表</span></span><br><span class="line">            List&lt;String&gt; keyList = scanResult.getResult();</span><br><span class="line">            <span class="keyword">if</span> (keyList != <span class="keyword">null</span> &amp;&amp; keyList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String key : keyList) &#123;</span><br><span class="line">                    pipeline.del(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 批量删除</span></span><br><span class="line">                pipeline.syncAndReturnAll</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = scanResult.getStringCursor();</span><br><span class="line">            <span class="comment">// 如果游标变为0，说明扫描完毕</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"0"</span>.equals(cursor)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前Redis是否为master节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMaster</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">    String[] data = jedis.info(<span class="string">"Replication"</span>).split(<span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String line : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"role:master"</span>.equals(line.trim())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>批量操作的方法</strong></p>
<p>见 9.5 节 “无底洞优化”</p>
<p><strong>使用Lua、事务等特性的方法</strong></p>
<ol>
<li>将事务中所有的key添加hashtag。</li>
<li>使用CRC16计算hashtag对应的slot。</li>
<li>获取指定slot对应的节点连接池JedisPool。</li>
<li>在JedisPool上执行事务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String hastag = <span class="string">"&#123;user&#125;"</span>;</span><br><span class="line"><span class="comment">// 用户A的关注表</span></span><br><span class="line">String userAFollowKey = hastag + <span class="string">":a:follow"</span>;</span><br><span class="line"><span class="comment">// 用户B的粉丝表</span></span><br><span class="line">String userBFanKey = hastag + <span class="string">":b:fans"</span>;</span><br><span class="line"><span class="comment">// 计算hashtag对应的slot</span></span><br><span class="line"><span class="keyword">int</span> slot = JedisClusterCRC16.getSlot(hastag);</span><br><span class="line"><span class="comment">// 获取指定slot的JedisPool</span></span><br><span class="line">JedisPool jedisPool = jedisCluster.getConnectionHandler().getJedisPoolFromSlot(slot);</span><br><span class="line"><span class="comment">// 在当个节点上执行事务</span></span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">// 用户A的关注表加入用户B，用户B的粉丝列表加入用户A</span></span><br><span class="line">    Transaction transaction = jedis.multi();</span><br><span class="line">    transaction.sadd(userAFollowKey, <span class="string">"user:b"</span>);</span><br><span class="line">    transaction.sadd(userBFanKey, <span class="string">"user:a"</span>);</span><br><span class="line">    transaction.exec();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis!= <span class="keyword">null</span>)</span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-5-3-ASK-重定向异常"><a href="#8-5-3-ASK-重定向异常" class="headerlink" title="8.5.3 ASK 重定向异常"></a>8.5.3 ASK 重定向异常</h4><p><strong>客户端ASK重定向流程</strong></p>
<p>当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点。<br>当客户端向源节点发送命令时，如果不存在键对象，则可能存在于目标节点，这时源节点会回复ASK重定向异常。格式如下：<code>（error）ASK {slot}{targetIP}：{targetPort}</code>。</p>
<p><img src="https://i.loli.net/2019/12/20/hVxSlLbJZdyOC2u.png" alt="ASK重定向.png"></p>
<ul>
<li>ASK重定向说明集群正在进行slot数据迁移，客户端不会更新slots缓存</li>
<li>MOVED重定向说明键对应的槽已经指定到新的节点，因此需要更新slots缓存。</li>
<li>当在集群环境下使用mget、mset等批量操作时，slot迁移数据期间由于键列表无法保证在同一节点，会导致大量错误</li>
</ul>
<h3 id="8-6-故障转移"><a href="#8-6-故障转移" class="headerlink" title="8.6 故障转移"></a>8.6 故障转移</h3><h4 id="8-6-1-故障发现"><a href="#8-6-1-故障发现" class="headerlink" title="8.6.1 故障发现"></a>8.6.1 故障发现</h4><p>故障发现也是通过消息传播机制实现的</p>
<p><strong>主观下线（pfail）</strong></p>
<p>指某个节点认为另一个节点不可用，不是最终的故障判定</p>
<p><img src="https://i.loli.net/2019/12/20/E91xMbiN6GaDVFH.png" alt="主观下线.png"></p>
<center>主观下线流程</center>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定时任务,默认每秒执行<span class="number">10</span>次</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clusterCron</span><span class="params">()</span>:</span></span><br><span class="line">    // ... 忽略其他代码</span><br><span class="line">    <span class="keyword">for</span>(node <span class="keyword">in</span> server.cluster.nodes):</span><br><span class="line">    // 忽略自身节点比较</span><br><span class="line">    <span class="keyword">if</span>(node.flags == CLUSTER_NODE_MYSELF):</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    // 系统当前时间</span><br><span class="line">    long now = mstime();</span><br><span class="line">    // 自身节点最后一次与该节点PING通信的时间差</span><br><span class="line">    long delay = now - node.ping_sent;</span><br><span class="line">    // 如果通信时间差超过cluster_node_timeout，将该节点标记为PFAIL（主观下线）</span><br><span class="line">    <span class="keyword">if</span> (delay &gt; server.cluster_node_timeout) :</span><br><span class="line">        node.flags = CLUSTER_NODE_PFAIL;</span><br></pre></td></tr></table></figure>

<p><strong>客观下线</strong></p>
<p>当某个节点判断另一个节点主观下线，通过<strong>Gossip</strong>消息传播，集群内节点不断收集到故障节点的下线报告。当<strong>半数以上</strong>持有槽的主节点都标记某个节点是主观下线时，触发<strong>客观下线</strong></p>
<h4 id="8-6-2-故障恢复"><a href="#8-6-2-故障恢复" class="headerlink" title="8.6.2 故障恢复"></a>8.6.2 故障恢复</h4><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，从而保证集群的高可用</p>
<p><img src="https://i.loli.net/2019/12/20/wXu8mxZkfeDsdql.png" alt="故障选举流程.png"></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Allen Timmger
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://timmger.github.io/2019/12/05/Redis实战/" title="Redis开发运维">https://timmger.github.io/2019/12/05/Redis实战/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NoSQL/" rel="tag"><i class="fa fa-tag"></i> NoSQL</a>
          
            <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i> Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/05/SQLAdvance/" rel="next" title="SQL 进阶教程">
                <i class="fa fa-chevron-left"></i> SQL 进阶教程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Allen Timmger">
            
              <p class="site-author-name" itemprop="name">Allen Timmger</p>
              <p class="site-description motion-element" itemprop="description">ザ・ワールド</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Timmger" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:timmgerable@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/AllenTimmger" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://design.timmger.site/dist/design.html" title="我的设计站" target="_blank">我的设计站</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis简介"><span class="nav-number">1.</span> <span class="nav-text">1. Redis简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-什么是-Redis"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是 Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Redis-可以做什么"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Redis 可以做什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-安装-Redis"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 安装 Redis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis-常用命令和数据结构"><span class="nav-number">2.</span> <span class="nav-text">2. Redis 常用命令和数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-全局命令"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 全局命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-数据结构与内部编码"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 数据结构与内部编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-单线程架构"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 单线程架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-字符串"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-命令"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-内部编码"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-使用场景"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Hash"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-命令"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-内部编码"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-使用场景"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-列表"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-命令"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-内部编码"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.6.2 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-使用场景"><span class="nav-number">2.6.3.</span> <span class="nav-text">2.6.3 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-集合"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-命令"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.7.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-内部编码"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.7.2 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-使用场景"><span class="nav-number">2.7.3.</span> <span class="nav-text">2.7.3 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-有序集合"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-命令"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.8.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-2-内部编码"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.8.2 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-3-使用场景"><span class="nav-number">2.8.3.</span> <span class="nav-text">2.8.3 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-键管理"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 键管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-1-单键管理"><span class="nav-number">2.9.1.</span> <span class="nav-text">2.9.1 单键管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-2-遍历键"><span class="nav-number">2.9.2.</span> <span class="nav-text">2.9.2 遍历键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-3-数据库管理"><span class="nav-number">2.9.3.</span> <span class="nav-text">2.9.3 数据库管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-多功能"><span class="nav-number">3.</span> <span class="nav-text">3. 多功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-慢查询分析"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 慢查询分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-配置参数"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 配置参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-配置建议"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 配置建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Redis-Shell"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 Redis Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-redis-cli"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 redis-cli</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-redis-server"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 redis-server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-redis-benchmark"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 redis-benchmark</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Pipeline"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 Pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-事务与Lua"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 事务与Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-事务"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-Lua"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 Lua</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-Redis-与-Lua"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3 Redis 与 Lua</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-案例"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.4.4 案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-管理-Lua-脚本"><span class="nav-number">3.4.5.</span> <span class="nav-text">3.4.5 管理 Lua 脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Bitmaps"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 Bitmaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-命令"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-Bitmaps分析"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2 Bitmaps分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-HyperLogLog"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-发布订阅"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-命令"><span class="nav-number">3.7.1.</span> <span class="nav-text">3.7.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2-使用场景"><span class="nav-number">3.7.2.</span> <span class="nav-text">3.7.2 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-GEO"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 GEO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-命令"><span class="nav-number">3.8.1.</span> <span class="nav-text">3.8.1 命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-客户端"><span class="nav-number">4.</span> <span class="nav-text">4. 客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Jedis"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Jedis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-持久化"><span class="nav-number">5.</span> <span class="nav-text">5. 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-RDB"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-触发机制"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 触发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-RDB文件的处理"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 RDB文件的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-RDB-优缺点"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.3 RDB 优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-AOF"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-使用-AOF"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 使用 AOF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-命令写入"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2　命令写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-文件同步"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3　文件同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-重写"><span class="nav-number">5.2.4.</span> <span class="nav-text">5.2.4　重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-重启加载"><span class="nav-number">5.2.5.</span> <span class="nav-text">5.2.4　重启加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5-文件校验"><span class="nav-number">5.2.6.</span> <span class="nav-text">5.2.5 文件校验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-复制"><span class="nav-number">6.</span> <span class="nav-text">6. 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-配置"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-建立复制"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 建立复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-断开复制"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 断开复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-安全性"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.1.3 安全性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-传输延迟"><span class="nav-number">6.1.4.</span> <span class="nav-text">6.1.4 传输延迟</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-拓扑"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 拓扑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-原理"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-问题"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-读写分离"><span class="nav-number">6.4.1.</span> <span class="nav-text">6.4.1 读写分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-规避全量复制"><span class="nav-number">6.4.2.</span> <span class="nav-text">6.4.2 规避全量复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-规避复制风暴"><span class="nav-number">6.4.3.</span> <span class="nav-text">6.4.3 规避复制风暴</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-哨兵-Sentinel"><span class="nav-number">7.</span> <span class="nav-text">7. 哨兵(Sentinel)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-基本概念"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-主从复制的问题"><span class="nav-number">7.1.1.</span> <span class="nav-text">7.1.1 主从复制的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-Redis-Sentinel的高可用性"><span class="nav-number">7.1.2.</span> <span class="nav-text">7.1.2 Redis Sentinel的高可用性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-安装部署"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 安装部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-API"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-客户端连接"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 客户端连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-实现原理"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-高可用读写分离"><span class="nav-number">7.6.</span> <span class="nav-text">7.6 高可用读写分离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-集群"><span class="nav-number">8.</span> <span class="nav-text">8. 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-数据分布"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 数据分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-搭建集群"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 搭建集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-节点通信"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 节点通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-集群伸缩"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 集群伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-1-扩容集群"><span class="nav-number">8.4.1.</span> <span class="nav-text">8.4.1 扩容集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-2-收缩集群"><span class="nav-number">8.4.2.</span> <span class="nav-text">8.4.2 收缩集群</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-请求路由"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 请求路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-1-请求重定向"><span class="nav-number">8.5.1.</span> <span class="nav-text">8.5.1 请求重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-2-Smart客户端"><span class="nav-number">8.5.2.</span> <span class="nav-text">8.5.2 Smart客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-3-ASK-重定向异常"><span class="nav-number">8.5.3.</span> <span class="nav-text">8.5.3 ASK 重定向异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-故障转移"><span class="nav-number">8.6.</span> <span class="nav-text">8.6 故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-6-1-故障发现"><span class="nav-number">8.6.1.</span> <span class="nav-text">8.6.1 故障发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-6-2-故障恢复"><span class="nav-number">8.6.2.</span> <span class="nav-text">8.6.2 故障恢复</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Allen Timmger</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Timmger.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://timmger.github.io/2019/12/05/Redis实战/';
          this.page.identifier = '2019/12/05/Redis实战/';
          this.page.title = 'Redis开发运维';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Timmger.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("iT4XyBMDp0Pyz0cKOytLfnfL-gzGzoHsz", "QjKlcR3aK5ao12eaYIzuUR8I");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":180,"height":360},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body>
</html>
